package com.coding.meet.util

import com.coding.meet.models.Achievement
import com.coding.meet.models.Article
import com.coding.meet.models.Experience
import com.coding.meet.models.FAQ
import com.coding.meet.models.Project
import com.coding.meet.models.Service
import com.coding.meet.models.Social
import com.coding.meet.models.Testimonial

object Constants {
    const val WEBSITE_NAME = "Coding Meet"

    const val BIO =
        "Hello! I‚Äôm Meet, an Android developer passionate about building apps with Kotlin, Java, KMP, and Jetpack Compose. Through my YouTube channel, GitHub projects, and this website, I share tutorials, source code, and practical guides to help developers improve their skills. I also offer custom Android development services, including app creation, bug fixing, and SDK updates. Let‚Äôs simplify Android development together! \uD83D\uDE80"

    const val NAMASTE_TEXT = "Namaste üôè"

    const val WELCOME_TEXT = "Welcome to my portfolio website"

    const val EMAIL_ID = "meetb2602@gmail.com"

    private const val GITHUB_USER_NAME = "Coding-Meet"

    private const val TOTAL_PUBLIC_REPOS = 104

    const val TOTAL_PAGE = TOTAL_PUBLIC_REPOS / 100 + 1

    const val GITHUB_BASE_URL = "https://api.github.com/users/$GITHUB_USER_NAME/repos"

    private const val MEDIUM_USER_NAME = "@meet26"

    const val MEDIUM_BASE_URL =
        "https://api.rss2json.com/v1/api.json?rss_url=https://medium.com/feed/$MEDIUM_USER_NAME"

    val projects = mutableListOf(
        Project(
            title = "News Kotlin Multiplatform App",
            shortDescription = "A Kotlin Compose Multiplatform news app for Android, iOS, Windows, macOS, and Linux.",
            longDescription = "The News KMP App is a Kotlin Compose Multiplatform (KMP) project that aims to provide a consistent news reading experience across multiple platforms, including Android, iOS, Windows, macOS, and Linux. This project leverages Kotlin's multiplatform capabilities to share code and logic while using Compose for UI, ensuring a seamless and native experience on each platform.",
            features = listOf(
                "Explore Top News Headlines: Stay updated with the day's top news stories effortlessly.",
                "Read Detailed Content: Dive deeper into your favorite news articles for comprehensive insights.",
                "Personalized Search: Easily find news articles tailored to your interests.",
                "Save for Later: Bookmark articles to read offline and enjoy uninterrupted reading pleasure.",
                "Cross-Platform Support: Seamless operation on Android, iOS, Windows, macOS, and Linux.",
                "Declarative UI with Jetpack Compose: Shared UI components across Android and desktop.",
                "Material Design and Material Design 3 support.",
                "Type-Safe Navigation using Jetpack Compose Navigation.",
                "MVVM Architecture with ViewModel for UI-related data.",
                "Robust Networking with Ktor for HTTP client-server communication.",
                "Efficient Image Loading using Coil.",
                "Local Data Storage with Room for all platforms.",
                "Key-value pair storage using DataStore.",
                "Build Configuration Management with BuildKonfig."
            ),
            technologies = listOf(
                "Kotlin",
                "Jetpack Compose",
                "Kotlin Multiplatform",
                "MVVM Architecture",
                "Room Database",
                "DataStore",
                "Ktor"
            ),
            libraries = listOf(
                "BuildKonfig",
                "Ktor",
                "Kermit",
                "Room",
                "DataStore",
                "Navigation",
                "kotlinx.coroutines",
                "Common ViewModel",
                "kotlinx.serialization"
            ),
            githubUrl = "https://github.com/Coding-Meet/News-KMP-App",
            imageUrls = listOf(
                "project/News-KMP-App.png"
            ),
            platform = listOf("Android", "iOS", "Windows", "macOS", "Linux"),
            youtubeVideoLink = "https://www.youtube.com/embed/Dq1jcsVQmtY",
            topics = listOf(
                "News",
                "Kotlin Multiplatform",
                "Jetpack Compose",
                "Networking",
                "Local Storage",
                "MVVM Architecture"
            ),
            stargazersCount = 121
        ),
        Project(
            title = "Gemini AI Kotlin Multiplatform App - Chat with Gemini AI üí¨‚ú®",
            shortDescription = "A KMP app enabling AI-powered conversations across Android, iOS, Desktop, and Web.",
            longDescription = "The Gemini AI KMP App is a Kotlin Compose Multiplatform project designed to target Android, iOS, Windows, macOS, Linux, and Web platforms. It is an application by Gemini AI where you can retrieve information from text and images in a conversational format. Additionally, it allows storing chats group-wise using SQLDelight and KStore, and facilitates changing the Gemini API key.",
            features = listOf(
                "Engage in conversations from any device, including smartphones, tablets, desktops, and web browsers",
                "Retrieve information from text and images in a conversational format.",
                "Store chats group-wise using SQLDelight and KStore.",
                "Facilitating changing the Gemini API key.",
                "Simple Clean UI with Animations"
            ),
            technologies = listOf(
                "Kotlin",
                "Clean Architecture",
                "Jetpack Compose for UI development",
                "Koin for Dependency Injection",
                "SQLDelight",
                "KStore",
                "Generative AI"
            ),
            libraries = listOf(
                "BuildKonfig",
                "Koin",
                "Ktor",
                "Kermit",
                "ViewModel",
                "Compose Multiplatform File Picker",
                "Multiplatform Settings",
                "SQLDelight",
                "KStore",
                "kotlinx.coroutines",
                "kotlinx.serialization",
                "kotlinx.datetime"
            ),
            githubUrl = "https://github.com/Coding-Meet/Gemini-AI-KMP-App",
            imageUrls = listOf(
                "project/Gemini-AI-KMP-App.png"
            ),
            platform = listOf("Android", "iOS", "Windows", "macOS", "Linux", "Web"),
            youtubeVideoLink = "https://www.youtube.com/embed/YhWhR6IVs_Y",
            topics = listOf(
                "AI",
                "Kotlin Multiplatform",
                "Jetpack Compose",
                "Chatbot",
                "SQLDelight",
                "KStore"
            ),
            stargazersCount = 80
        ),
        Project(
            title = "String Translator Desktop App",
            shortDescription = "A Jetpack Compose desktop app for translating multiple strings effortlessly.",
            longDescription = "String Translator Desktop App is a powerful desktop application built with Jetpack Compose, aiming to streamline the translation of strings for developers. It empowers users to seamlessly translate multiple strings into various languages, thereby optimizing the localization process.",
            githubUrl = "https://github.com/Coding-Meet/String-Translator-Desktop-App",
            imageUrls = listOf(
                "project/String_Translator_Desktop_App.png"
            ),
            features = listOf(
                "Bulk Translation: Translate multiple strings at once to target languages.",
                "Language Selection: Choose from a variety of supported languages for translation.",
                "Jetpack Compose UI: Enjoy an intuitive and visually appealing interface built with Jetpack Compose.",
                "Translation with Google Translate: Effortlessly translate your text using Google Translate without the need for an API key.",
                "Export to XML Format: Export translated strings to XML for seamless integration into your projects."
            ),
            technologies = listOf(
                "Kotlin",
                "Jetpack Compose Desktop",
                "Web Scraping"
            ),
            libraries = listOf(
                "Jetpack Compose",
                "Json",
                "Compose Multiplatform"
            ),
            platform = listOf("Windows", "macOS", "Linux"),
            topics = listOf(
                "Translation",
                "Localization",
                "Jetpack Compose Desktop",
                "Web Scraping"
            ),
            youtubeVideoLink = "https://www.youtube.com/embed/EDbxJkgJDf8",
            stargazersCount = 13
        ),
        Project(
            title = "Custom LCD Pattern Generator",
            shortDescription = "An Android app that generates Arduino C code for custom LCD patterns.",
            longDescription = "Custom LCD Pattern Generator is an Android application that allows users to create custom patterns for LCD screens and automatically generates Arduino C code for the given input pattern. It supports 16x2 and 20x4 LCD screens, enabling users to design single-character patterns effortlessly. The app features an intuitive UI, automatic code generation, and options to copy, share, and save patterns in .txt and .ino formats. Live on Play Store with 1K+ downloads.",
            githubUrl = null,
            appStoreUrl = "https://play.google.com/store/apps/details?id=com.Custom_LCD_Pattern_Generator&pcampaignid=web_share",
            imageUrls = listOf(),
            platform = listOf("Android"),
            features = listOf(
                "Create patterns for 16x2 LCD screens.",
                "Create patterns for 20x4 LCD screens.",
                "Create a pattern for a single character.",
                "Easily create any pattern with a user-friendly UI.",
                "Automatically generate code for input patterns.",
                "Easily copy code and share.",
                "Save files in .txt and .ino formats."
            ),
            topics = listOf(
                "LCD Pattern Generator",
                "Embedded Systems",
                "Code Generation",
                "Arduino",
                "Android App"
            ),
            technologies = listOf(
                "Kotlin",
                "XML",
                "Arduino C",
                "Android SDK"
            ),
            libraries = listOf(
                "Gson",
                "Google Play In-App Review",
                "Firebase Crashlytics",
                "Firebase Analytics",
                "AndroidX SplashScreen"
            ),
        ),
        Project(
            title = "Home Automation System",
            shortDescription = "Arduino-based real-time home automation system for remote control of appliances via a mobile app.",
            longDescription = "This project presents an Arduino-based real-time home automation system that allows users to remotely control and monitor home appliances like fans, lights, etc., using a mobile application. The system stores real-time data on the cloud, providing access from anywhere. The implementation integrates NodeMCU ESP8266 Wi-Fi Module, relay module, and IR receiver for communication and control. The Android application facilitates authentication, device control, and appliance state monitoring.",
            features = listOf(
                "Remote appliance control via mobile app",
                "Wi-Fi-based real-time control",
                "Appliance state monitoring and restoration",
                "User authentication for security",
                "Temperature monitoring",
                "Fan speed control",
                "IR sensor-based device control"
            ),
            technologies = listOf(
                "IoT", "Android", "Kotlin",
                "Arduino",
                "NodeMCU ESP8266",
                "Firebase (Realtime Database)",
                "Wi-Fi Communication"
            ),
            libraries = listOf(
                "Arduino IDE 2.0",
                "ESP8266WiFi Library",
                "Firebase Database KTX"
            ),
            githubUrl = null,
            youtubeVideoLink = "https://user-images.githubusercontent.com/71074485/203806866-debcef11-a8d1-4f91-99f3-f76b0423aba3.mp4",
            imageUrls = listOf(),
            platform = listOf("Android"),
            topics = listOf("Home Automation", "IoT", "Arduino", "Smart Home")
        ),
        Project(
            title = "Electric Vehicle",
            shortDescription = "Coded systems for electric vehicles using Arduino C.",
            longDescription = "Coded systems for electric vehicles using Arduino C.",
            technologies = listOf("Arduino C", "IoT"),
            githubUrl = null,
            imageUrls = listOf(),
            platform = listOf("Embedded Systems"),
            features = listOf("Motor control", "Battery monitoring"),
        ),
        Project(
            title = "Quillbot Web Scraping",
            shortDescription = "Automates content rewriting, saving time spent on manual tasks.",
            longDescription = "Automates content rewriting, saving time spent on manual tasks.",
            technologies = listOf("Python", "Web Scraping"),
            githubUrl = null,
            imageUrls = listOf(),
            platform = listOf("Desktop"),
            features = listOf("Content automation", "Web scraping"),
        ),
        Project(
            title = "Multi-Factor Authenticator App",
            shortDescription = "Enhances online security by generating unique, time-based verification codes.",
            longDescription = "Enhances online security by generating unique, time-based verification codes.",
            technologies = listOf("Android", "Kotlin"),
            githubUrl = null,
            imageUrls = listOf(),
            platform = listOf("Android"),
            features = listOf("Time-based codes", "Secure storage"),
        ),
        Project(
            title = "Daily Affirmation",
            shortDescription = "Provides daily affirmations and inspiring quotes with a wallpaper feature.",
            longDescription = "Provides daily affirmations and inspiring quotes with a wallpaper feature.",
            technologies = listOf("Android", "Kotlin"),
            githubUrl = null,
            imageUrls = listOf(),
            platform = listOf("Android"),
            features = listOf("Daily quotes", "Wallpaper customization"),
        ),
        Project(
            title = "Math Workout - Brain Exercise",
            shortDescription = "Offers a variety of math challenges for brain training.",
            longDescription = "Offers a variety of math challenges for brain training.",
            technologies = listOf("Android", "Kotlin"),
            githubUrl = null,
            imageUrls = listOf(),
            platform = listOf("Android"),
            features = listOf("Math puzzles", "Brain training"),
        ),
        Project(
            title = "Trivia App",
            shortDescription = "Enables users to answer questions across various categories and difficulty levels.",
            longDescription = "Enables users to answer questions across various categories and difficulty levels.",
            technologies = listOf("Android", "Kotlin"),
            githubUrl = null,
            imageUrls = listOf(),
            platform = listOf("Android"),
            features = listOf("Category-wise trivia", "Difficulty levels"),
        ),
        Project(
            title = "MeetMyShow",
            shortDescription = "An online movie ticket booking app developed in Kotlin.",
            longDescription = "An online movie ticket booking app developed in Kotlin.",
            technologies = listOf("Android", "Kotlin"),
            githubUrl = null,
            imageUrls = listOf(),
            platform = listOf("Android"),
            features = listOf("Movie listings", "Ticket booking"),
        ),
        Project(
            title = "Android Addict",
            shortDescription = "A React-based website providing Android component code for developers.",
            longDescription = "A React-based website providing Android component code for developers.",
            technologies = listOf("React", "JavaScript"),
            githubUrl = null,
            imageUrls = listOf(),
            platform = listOf("Web"),
            features = listOf("Code snippets", "Component guides"),
        ),
        Project(
            title = "Gamers Arena",
            shortDescription = "An app for hosting and joining gaming tournaments and events.",
            longDescription = "An app for hosting and joining gaming tournaments and events.",
            technologies = listOf("Android", "Kotlin"),
            githubUrl = null,
            imageUrls = listOf(),
            platform = listOf("Android"),
            features = listOf("Tournament management", "Event participation"),
        )
    )
    val articles = listOf(
        Article(
            title = "Automate Android Feature Creation with Gradle",
            shortDescription = "Learn how to automate Android feature creation using Gradle scripting.",
            thumbnail = "articles/template-to-feature.png",
            link = "https://medium.com/@meet26/automate-android-feature-creation-with-gradle-cfd51373e167",
            categories = listOf("Android", "Gradle", "Automation"),
            pubDate = "Dec 10, 2024",
            readTime = "7 min read"
        ),
        Article(
            title = "Part 2: Automating Reverse Feature to Template Transformation in Gradle",
            shortDescription = "Learn how to automate Android template creation using Gradle scripting.",
            thumbnail = "articles/feature-to-template.png",
            link = "https://medium.com/@meet26/part-2-automating-reverse-feature-to-template-transformation-in-gradle-3973880bb6ff",
            categories = listOf("Android", "Gradle", "Automation", "Android Studio"),
            pubDate = "Feb 18, 2025",
            readTime = "7 min read"
        ),
        Article(
            title = "Full Guide: How to Form Validation With Jetpack Compose in Kotlin",
            shortDescription = "A complete guide to implementing form validation in Jetpack Compose.",
            thumbnail = "articles/form-validation-jetpack-compose.png",
            link = "https://medium.com/@meet26/full-guide-how-to-form-validation-with-jetpack-compose-01e0464ae884",
            categories = listOf("Jetpack Compose", "Validation", "Kotlin"),
            pubDate = "Oct 1, 2024",
            readTime = "16 min read"
        ),
        Article(
            title = "Bottom Navigation Bar for compact screens & Navigation Rail for larger screens in Compose Multiplatform",
            shortDescription = "A guide on implementing bottom navigation for compact screens and navigation rail for larger screens.",
            thumbnail = "articles/bottom-navigation-bar-cmp.png",
            link = "https://medium.com/@meet26/how-to-integrate-bottom-navigation-bar-for-compact-screens-and-a-navigation-rail-for-larger-screens-c7dc3baab0e7",
            categories = listOf("Android", "Navigation", "UI Design"),
            pubDate = "Sep 20, 2024",
            readTime = "10 min read"
        ),
        Article(
            title = "How to Integrate ViewModel in Kotlin Multiplatform with Koin",
            shortDescription = "Learn how to use ViewModel in Kotlin Multiplatform projects with Koin.",
            thumbnail = "articles/viewmodel-kmp.png",
            link = "https://medium.com/@meet26/how-to-integrate-viewmodel-in-kotlin-multiplatform-with-koin-1a1134530215",
            categories = listOf("Kotlin Multiplatform", "ViewModel", "Dependency Injection"),
            pubDate = "Sep 11, 2024",
            readTime = "5 min read"
        )
    )
    val animatedTexts = listOf(
        "Meet",
        "Freelancer",
        "Native Android Developer",
        "Content Creator",
        "Kotlin Multiplatform Developer",
        "Blogger",
        "IOT Developer"
    )
    val experiences = listOf(
        Experience(
            title = "üì± Android Developer",
            company = "üíº Fiverr",
            type = "Freelance",
            startDate = "Jun 2023",
            endDate = "Present",
            location = "üåç Remote",
            description = "Collaborated with 30+ clients globally, delivering high-quality Android applications worth over $4,000. Maintained a 100% ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê rating, demonstrating expertise in Kotlin, Jetpack Compose, and modern Android development practices."
        ),
        Experience(
            title = "üé• Content Creator",
            company = "‚ñ∂Ô∏è YouTube",
            type = "Part-time",
            startDate = "Apr 2023",
            endDate = "Present",
            location = "üåç India ¬∑ Remote",
            description = "Founder of Coding Meet, a YouTube channel dedicated to Android development. Created 400+ videos covering Kotlin, Jetpack Compose, Compose Multiplatform and best practices, helping thousands of developers improve their skills."
        ),
        Experience(
            title = "‚úçÔ∏è Blogger",
            company = "üìù Medium",
            type = "Full-time",
            startDate = "Sep 2024",
            endDate = "Present",
            location = "üåç India ¬∑ Remote",
            description = "Publishing in-depth articles on Android development, Jetpack Compose, Kotlin Multiplatform, and Compose Multiplatform, sharing insights and best practices with a growing tech audience."
        ),
        Experience(
            title = "üõ†Ô∏è Android Development Intern",
            company = "üè¢ Private Tech Company",
            type = "Internship",
            startDate = "Dec 2022",
            endDate = "Jun 2023",
            duration = "7 mos",
            location = "üìç Surat, Gujarat, India ¬∑ On-site",
            description = "Worked on multiple Android projects, including a Multifactor Authenticator app, Trivia app, Daily Affirmation app, and party games like Truth & Dare and Never Have I Ever, gaining hands-on experience in Kotlin development."
        ),
        Experience(
            title = "üõ†Ô∏è Android Development Intern",
            company = "üè¢ Private Tech Company",
            type = "Internship",
            startDate = "May 2022",
            endDate = "Aug 2022",
            duration = "4 mos",
            location = "üìç Surat, Gujarat, India",
            description = "Contributed to a live health and fitness app project, enhancing Android development skills with Kotlin and practical exposure to real-world app development."
        )
    )

    const val seeAllReviewLink =
        "https://www.linkedin.com/search/results/content/?fromMember=%5B%22ACoAAELhKTgBk47IQWndyTP9JMkjqUet17RKdVU%22%5D&keywords=fiverr&origin=FACETED_SEARCH&sid=bU5"

    val testimonials = listOf(
        Testimonial(
            review = "I've worked with Meet before so when I wanted to get my app upgraded, I reached out to him again. Despite it being a Sunday, Meet upgraded my sdk version, and fixed a bug in a very short time. Will come to him again for any Android needs. :)",
            rating = 5.0,
            country = "United States",
            serviceName = "UPDATE_SDK_OR_GRADLE",
        ),
        Testimonial(
            review = "Everything was done very quickly, and the improvements made were remarkable. He also included detailed documentation and shared valuable recommendations. For these reasons and more, I've chosen Meet as my favorite developer. I highly recommend their services.",
            rating = 5.0,
            country = "Mexico",
            serviceName = "UPDATE_SDK_OR_GRADLE",
        ),
        Testimonial(
            review = "Completed the work very quickly, did the work as promised and in very less time. good work",
            rating = 5.0,
            country = "India",
            serviceName = "UPDATE_SDK_OR_GRADLE",
        ),
        Testimonial(
            review = "he provided a very good service and I really like it fast and easy",
            rating = 4.3,
            country = "Nigeria",
            serviceName = "UPDATE_SDK_OR_GRADLE",
        ),
        Testimonial(
            review = "great work",
            rating = 5.0,
            country = "United States",
            serviceName = "UPDATE_SDK_OR_GRADLE",
        ),
        Testimonial(
            review = "work is great",
            rating = 4.7,
            country = "United States",
            serviceName = "UPDATE_SDK_OR_GRADLE",
        ),
        Testimonial(
            review = "did great and fast job. definitely working with him again",
            rating = 5.0,
            country = "Morocco",
            serviceName = "UPDATE_SDK_OR_GRADLE",
        ),
        Testimonial(
            review = "Quick responsiveness",
            rating = 5.0,
            country = "Myanmar [Burma]",
            serviceName = "AI_WORK",
        ),
        Testimonial(
            review = "Very fantastic work done. will surely work again in future",
            rating = 5.0,
            country = "India",
            serviceName = "FIX_BUG_IMPROVE_APP",
        ),
        Testimonial(
            review = "He does a very good job, he understands what you ask him, he is very kind and understanding, very detailed in all the work, a professional result and in addition to that he attends to you very quickly, I recommend him, a very good person.",
            rating = 5.0,
            country = "Bolivia",
            serviceName = "FIX_BUG_IMPROVE_APP",
        ),
        Testimonial(
            review = "Meet's is one of the best freelancers I've had the opportunity to work with. His work is of very high quality. He knows how to listen to feedback and has excellent communication skills. I highly recommend his services!",
            rating = 5.0,
            country = "Bolivia",
            serviceName = "FIX_BUG_IMPROVE_APP",
        ),
        Testimonial(
            review = "I was surprised by the speed and experience that meet has. For this and more I have chosen meet as my favorite developer. I highly recommend it.",
            rating = 5.0,
            country = "Mexico",
            serviceName = "UPDATE_SDK_OR_GRADLE",
        ),
        Testimonial(
            review = "Very good app Developer üëç Fix all Bugs form my app Thanks for all things üôè",
            rating = 5.0,
            country = "Pakistan",
            serviceName = "UPDATE_SDK_OR_GRADLE",
        ),
        Testimonial(
            review = "I liked working with him. Great professional. Very fast delivery time",
            rating = 5.0,
            country = "Spain",
            serviceName = "UPDATE_SDK_OR_GRADLE",
        ),
        Testimonial(
            review = "Very happy with the delivery! I had a very old app and not a lot of developers can do update it perfectly. Meet is a very good and did it in a short span of time. I'll hire him again if I need anything else!",
            rating = 5.0,
            country = "United States",
            serviceName = "UPDATE_SDK_OR_GRADLE",
        ),
        Testimonial(
            review = "Once again, everything is fine, excellent work.",
            rating = 5.0,
            country = "Spain",
            serviceName = "UPDATE_SDK_OR_GRADLE",
        ),
        Testimonial(
            review = "I always work with him because he understands very well what I want. He gives me a lot of confidence.",
            rating = 5.0,
            country = "Spain",
            serviceName = "AI_WORK",
        ),
        Testimonial(
            review = "Gave me code thumbs up 5 star",
            rating = 5.0,
            country = "United States",
            serviceName = "UPDATE_SDK_OR_GRADLE",
        ),
        Testimonial(
            review = "I have worked on several projects with him and I think he is the best.",
            rating = 5.0,
            country = "Spain",
            serviceName = "UPDATE_SDK_OR_GRADLE",
        ),
        Testimonial(
            review = "Communication was good he answered very quickly. I sent him my code and he told me how long it takes and that he knows how to solve the problem. He sent me the solved code and it worked. I highly recommend him!",
            rating = 5.0,
            country = "Germany",
            serviceName = "FIX_BUG_IMPROVE_APP",
        ),
        Testimonial(
            review = "He is a great professional. and it is the second time that he worked with him and it was super good.",
            rating = 5.0,
            country = "Spain",
            serviceName = "UPDATE_SDK_OR_GRADLE",
        ),
        Testimonial(
            review = "el mejor, super genio. un gusto trabajar con el.",
            rating = 5.0,
            country = "Spain",
            serviceName = "UPDATE_SDK_OR_GRADLE",
        ),
        Testimonial(
            review = "I had a problem with the OpenAi api request to generate Images with the Api. He helped me to fix the problem. Very good and clear communication and he delivered the edited code very fast. Very impressed of him.",
            rating = 5.0,
            country = "Germany",
            serviceName = "FIX_BUG_IMPROVE_APP",
        ),
        Testimonial(
            review = "Meet is the best, I highly recommend him!",
            rating = 5.0,
            country = "United States",
            serviceName = "UPDATE_SDK_OR_GRADLE",
        ),
        Testimonial(
            review = "Very satisfied with the work received.",
            rating = 5.0,
            country = "Cyprus",
            serviceName = "FIX_BUG_IMPROVE_APP",
        ),
        Testimonial(
            review = "Developer replied very fast, delivered all changes on time and his work was exceptional. He's very skilled and very very friendly. Our communication was excellent and he has very good skills with android development, java, git and more. I am very satisfied! He is highly recommended!",
            rating = 5.0,
            country = "Greece",
            serviceName = "FIX_BUG_IMPROVE_APP",
        ),
        Testimonial(
            review = "Very responsive and very good communication. Did the work very quickly and fully to the scope. Would recommend 100%.",
            rating = 5.0,
            country = "Cyprus",
            serviceName = "UPDATE_SDK_OR_GRADLE",
        ),
        Testimonial(
            review = "fast delivery",
            rating = 5.0,
            country = "Philippines",
            serviceName = "BUILD_NEW_ANDROID_APP",
        ),
        Testimonial(
            review = "Professional communication, fast delivery ! THX",
            rating = 5.0,
            country = "United Arab Emirates",
            serviceName = "UPDATE_SDK_OR_GRADLE",
        )
    ).shuffled()

    val services = listOf(
        Service(
            title = "\uD83D\uDCF1 Build a New Android App",
            description = "Want to create your own Android app? I can build it for you!",
            features = listOf(
                "Develop using Kotlin, Java, Jetpack Compose, and Kotlin Multiplatform",
                "Implement Coroutines, Koin, Dagger Hilt, Retrofit, and Room for efficient architecture",
                "Design UI with XML and Jetpack Compose",
                "Integrate third-party REST APIs seamlessly",
                "Use Navigation Components for smooth app flow",
                "Follow MVVM / Clean Architecture for maintainable code",
                "Optimize image loading with Glide and Coil",
                "Implement Firebase Crashlytics and Google Analytics for monitoring and insights",
                "Utilize Google APIs like Maps and Sign-In",
                "Enable Google Play In-App Updates for seamless user experience",
                "Integrate Firebase Realtime Database, Firestore, and Push Notifications"
            ),
            imageUrls = listOf(
                "services/build_android_app.png"
            ),
        ),
        Service(
            title = "\uD83D\uDD27 Fix Bugs & Improve Your App",
            description = "Is your app crashing or running slow? I will fix it!",
            features = listOf(
                "Resolve UI and layout issues for a better user experience",
                "Optimize app performance to run smoothly",
                "Fix code errors and bugs efficiently",
                "Resolve version update errors and compatibility issues",
                "Debug and fix Android SDK and Gradle problems",
                "Upgrade SDK and API level to meet the latest standards",
                "Identify and fix app crashes for a stable experience",
                "Troubleshoot and resolve specific bugs",
                "Fix importing issues in Android Studio",
                "Debug Jetpack Compose UI issues",
                "Resolve Signup/Login authentication problems",
                "Fix Firebase integration issues (Firestore, Realtime Database, Notifications)",
                "Debug Android Studio SDK-related problems"
            ),
            imageUrls = listOf(
                "services/fix_bug.png"
            ),
        ),
        Service(
            title = "\uD83D\uDE80 Update Your Android App (SDK & Gradle)",
            description = "Need to update your app for the latest Android version?",
            features = listOf(
                "Update target SDK to Android 14 (API level 35) with necessary code adjustments",
                "Fix Gradle and dependency issues",
                "Upgrade SDK and API levels for better performance and security",
                "Debug and resolve Android app bugs",
                "Fix version update errors and compatibility issues",
                "Resolve Android SDK-related errors",
                "Identify and fix app crashes and runtime errors",
                "Fix specific bugs affecting app performance",
                "Troubleshoot APK issues and build problems",
                "Resolve errors when uploading to the Play Store"
            ),
            imageUrls = listOf(
                "services/update_android_app.png"
            ),
        ),
        Service(
            title = "\uD83E\uDD16 Add AI Chatbot to Your App (Google Gemini & GPT-4)",
            description = "Want to add an AI chatbot? I can integrate Google Gemini AI for smart responses!",
            features = listOf(
                "Welcome Screen for a friendly start",
                "Chat Screen with AI-powered conversations using GPT-4 & Gemini API",
                "Internet Connectivity Check to ensure the app stays online",
                "Clipboard Manager for easy message copying",
                "Text Selection for copying and sharing text seamlessly",
                "Popup Menus for enhanced message interaction",
                "Room Database to store chat history locally",
                "Robot Interaction: Insert, view, update, and delete robot characters",
                "Text-to-Speech (TTS) & Voice-to-Text (VTT) support for accessibility",
                "API Key Security with encrypted SharedPreferences"
            ),
            imageUrls = listOf(
                "services/chatbot.png"
            ),
        )
    )
    val faqs = listOf(
        FAQ(
            question = "What technologies do you use for Android app development?",
            answer = "I use Kotlin, Java, Jetpack Compose, and Kotlin Multiplatform, along with MVVM, Clean Architecture, and various Android libraries."
        ),
        FAQ(
            question = "Can you fix bugs in my existing Android app?",
            answer = "Yes, I can debug and fix issues related to UI, crashes, Gradle, SDK updates, and general app performance."
        ),
        FAQ(
            question = "Is source code required to fix bugs in the app?",
            answer = "Yes, source code is required to diagnose and fix bugs in your application."
        ),
        FAQ(
            question = "Can you upgrade my app to the latest Android version?",
            answer = "Yes, I can update your app‚Äôs target SDK to Android 14 (API level 35) and make necessary code adjustments for compatibility."
        ),
        FAQ(
            question = "Is source code required to update the app?",
            answer = "Yes, source code is required to update the SDK and fix any compatibility issues in your application."
        ),
        FAQ(
            question = "Do you provide AI chatbot integration?",
            answer = "Yes, I can integrate AI-powered chatbots using Google Gemini API and GPT-3 for intelligent conversations."
        ),
        FAQ(
            question = "Do you provide Play Store upload support?",
            answer = "Yes, I can fix Play Store upload issues, including APK problems and version compatibility errors."
        ),
        FAQ(
            question = "Can you integrate Firebase services into my app?",
            answer = "Yes, I can integrate Firebase services such as Realtime Database, Firestore, Authentication, Push Notifications, and Crashlytics."
        ),
        FAQ(
            question = "Do you work with third-party APIs?",
            answer = "Yes, I can integrate third-party REST APIs to enhance your app‚Äôs functionality."
        ),
        FAQ(
            question = "What do you need to get started?",
            answer = "I need access to your app‚Äôs source code, preferably through a Git repository, along with the project requirements."
        ),
        FAQ(
            question = "How long does it take to complete a project?",
            answer = "The timeline depends on the complexity of the project. Simple fixes take a few hours, while full app development may take weeks or months."
        )
    )

    val socials = listOf(
        Social(
            title = "Youtube",
            link = "https://youtube.com/@codingmeet26?si=_2Mu6ozuCdYuqihA",
            lightImage = "social/youtube.svg"
        ),
        Social(
            title = "GitHub",
            link = "https://github.com/Coding-Meet",
            lightImage = "social/github.svg",
            darkImage = "social/github_dark_mode.svg"
        ),
        Social(
            title = "Gmail",
            link = "mailto:$EMAIL_ID",
            lightImage = "social/mail.svg"
        ),
        Social(
            title = "Medium",
            link = "https://www.medium.com/@meet26",
            lightImage = "social/medium.svg",
            darkImage = "social/medium_dark_mode.svg"
        ),
        Social(
            title = "Stack Overflow",
            link = "https://stackoverflow.com/users/13082664/meet",
            lightImage = "social/stack_overflow.svg"
        ),
        Social(
            title = "LinkedIn",
            link = "https://www.linkedin.com/in/coding-meet",
            lightImage = "social/linkedin.svg"
        ),
        Social(
            title = "Instagram",
            link = "https://www.instagram.com/codingmeet26/",
            lightImage = "social/instagram.svg"
        ),
        Social(
            title = "Twitter",
            link = "https://www.twitter.com/CodingMeet",
            lightImage = "social/twitter.svg"
        ),
        Social(
            title = "Telegram",
            link = "https://www.telegram.me/Meetb26",
            lightImage = "social/telegram.svg"
        ),
        Social(
            title = "Buy Me Coffee",
            link = "https://www.buymeacoffee.com/CodingMeet",
            lightImage = "social/buy_me_coffee.svg",
            darkImage = "social/buy_me_coffee_dark_mode.svg"
        ),
    )

    val achievements = listOf(
        Achievement(
            title = "üì∫ 3.8K+ YouTube Subscribers",
            subtitle = "Creating 400+ videos for developers",
            lightImage = "social/youtube.svg"
        ),
        Achievement(
            title = "‚≠ê 400+ GitHub Stars",
            subtitle = "Trusted by 400+ developers and followers",
            lightImage = "social/github.svg",
            darkImage = "social/github_dark_mode.svg"
        ),
        Achievement(
            title = "üì¶ 30+ Completed Orders",
            subtitle = "Delivering 30+ custom-built projects",
            lightImage = "social/fiverr.svg"
        ),
        Achievement(
            title = "ü§ù 200+ Contributions",
            subtitle = "Actively supporting developers on Telegram, Instagram, LinkedIn, Facebook & Twitter",
            lightImage = "social/contributions.svg",
            darkImage = "social/contributions_dark.svg"
        ),
        Achievement(
            title = "üí¨ 60+ Answers",
            subtitle = "Guiding developers with 60+ solutions on Stack Overflow",
            lightImage = "social/stack_overflow.svg"
        ),
        Achievement(
            title = "‚úçÔ∏è 350+ Claps",
            subtitle = "Sharing insights with 5 published articles on ProAndroidDev",
            lightImage = "social/medium.svg",
            darkImage = "social/medium_dark_mode.svg"
        )
    )



    val mediumArticleDummyData = """
                    {"status":"ok","feed":{"url":"https://medium.com/feed/@meet26","title":"Stories by Meet on Medium","link":"https://medium.com/@meet26?source=rss-b69c0e11154c------2","author":"","description":"Stories by Meet on Medium","image":"https://cdn-images-1.medium.com/fit/c/150/150/1*kyarwWs9afYOsHx9TKScyw.png"},"items":[{"title":"Automate Android Feature Creation with Gradle","pubDate":"2024-12-10 12:09:09","link":"https://proandroiddev.com/automate-android-feature-creation-with-gradle-cfd51373e167?source=rss-b69c0e11154c------2","guid":"https://medium.com/p/cfd51373e167","author":"Meet","thumbnail":"","description":"\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*uSl5aXXimCMVBQUsv26QDw.png\"></figure><p>Creating features in Android development often involves repetitive tasks like setting up screen files, UI state management, and ViewModel classes. To streamline this process, we can use a <strong>Gradle Task</strong> to automatically generate these files based on reusable templates. This article will guide you step-by-step on how to implement and use this Gradle-based solution.</p>\n<blockquote><strong>What Will Be Generated?</strong></blockquote>\n<p>For every new screen, the Gradle task will generate:</p>\n<ol>\n<li>\n<strong>&lt;ScreenName&gt;Screen.kt</strong>: A composable function that defines the screen's\u00a0UI.</li>\n<li>\n<strong>&lt;ScreenName&gt;UiState.kt</strong>: A data class representing the screen's UI state and\u00a0events.</li>\n<li>\n<strong>&lt;ScreenName&gt;ViewModel.kt</strong>: A ViewModel that manages the UI state and handles user interactions.</li>\n</ol>\n<blockquote><strong>How It\u00a0Works</strong></blockquote>\n<p>The custom Gradle task simplifies the process of generating new feature files in Android by using pre-defined templates. These templates are placed in the <strong>featureTemplate </strong>directory and are used to create new screen features with consistent structure and\u00a0code.</p>\n<blockquote>\n<strong>1</strong>. <strong>Directory Structure and Template\u00a0Files</strong>\n</blockquote>\n<p>The Gradle task looks for templates in a directory called <strong>featureTemplate</strong>. Inside this directory, you can organize different feature templates into subfolders. Each subfolder corresponds to a template type. For example, the <strong>screenTemplate </strong>subfolder will contain the basic files needed to generate a new screen, such as <strong>Screen.kt</strong>, <strong>UiState.kt</strong>, and <strong>ViewModel.kt</strong>.</p>\n<p>Example of the directory structure:</p>\n<pre>featureTemplate/<br>    \u251c\u2500\u2500 screenTemplate/<br>    \u2502   \u251c\u2500\u2500 Screen.kt<br>    \u2502   \u251c\u2500\u2500 UiState.kt<br>    \u2502   \u2514\u2500\u2500 ViewModel.kt</pre>\n<blockquote><strong>2. Generated Directory Structure</strong></blockquote>\n<p>When you run the Gradle task to generate a new feature, the task creates a new directory for the feature in your project\u2019s <strong>src/main/java/com/example/app/</strong> folder. This generated directory will contain files\u00a0like:</p>\n<pre>src/main/java/com/example/app/&lt;FeatureName&gt;/<br>    \u251c\u2500\u2500 &lt;FeatureName&gt;Screen.kt<br>    \u251c\u2500\u2500 &lt;FeatureName&gt;UiState.kt<br>    \u2514\u2500\u2500 &lt;FeatureName&gt;ViewModel.kt</pre>\n<p>For instance, if you create a feature called <strong>Home</strong>, the task will generate:</p>\n<pre>src/main/java/com/example/app/home/<br>    \u251c\u2500\u2500 HomeScreen.kt<br>    \u251c\u2500\u2500 HomeUiState.kt<br>    \u2514\u2500\u2500 HomeViewModel.kt</pre>\n<blockquote><strong>3. Template Customization</strong></blockquote>\n<p>The templates in the <strong>featureTemplate </strong>directory use placeholders like <strong>{{FeatureName}}</strong>, <strong>{{packageName}}</strong>, and <strong>{{className}}</strong>. When the Gradle task runs, these placeholders are automatically replaced with actual values based on the <strong>featureName </strong>you provide and the configuration of your\u00a0project.</p>\n<p>For example, if your feature name is <strong>Home</strong>, the template file <strong>Screen.kt</strong> might look like\u00a0this:</p>\n<p><strong>Template (Screen.kt)</strong>:</p>\n<pre>package {{packageName}}<br><br>import androidx.compose.runtime.Composable<br><br>@Composable<br>fun {{className}}Screen() {<br>    // TODO: Implement the UI for {{className}}Screen<br>}</pre>\n<p>When you run the task with <strong>-PfeatureName=Home</strong>, the task will replace <strong>{{packageName}}</strong> with your base package name (e.g., <strong>com.example.app</strong>) and <strong>{{className}}</strong> with <strong>Home</strong>. This results in the following generated file:</p>\n<p><strong>Generated (HomeScreen.kt)</strong>:</p>\n<pre>package com.example.app<br><br>import androidx.compose.runtime.Composable<br><br>@Composable<br>fun HomeScreen() {<br>    // TODO: Implement the UI for HomeScreen<br>}</pre>\n<p>This customization process ensures that each feature file is tailored to your project without manual\u00a0editing.</p>\n<blockquote>I<strong>mplementation of Feature Template Automation in Android\u00a0Project</strong>\n</blockquote>\n<p>To implement the automation of feature generation in your Android project, follow the steps outlined below. These steps will guide you in setting up the necessary Gradle task, preparing template files, and using those templates to generate new features automatically.</p>\n<blockquote><strong>Step 1: Setting Up the Gradle\u00a0Task</strong></blockquote>\n<p>The first step is to define a custom Gradle task in your <strong>build.gradle.kts</strong> file. This task will automatically generate the necessary feature files based on the template you\u00a0specify.</p>\n<h4>How It\u00a0Works:</h4>\n<ol><li>\n<strong>Defining Properties:</strong> The task will accept two properties:</li></ol>\n<ul>\n<li>\n<strong>featureName</strong>: The name of the feature you want to generate (e.g.,\u00a0<strong>Home</strong>).</li>\n<li>\n<strong>templateName</strong>: The type of template you want to use (e.g., <strong>screenTemplate</strong>).</li>\n<li>\n<strong>rootFolderName</strong>: Identifies the directory containing your template files (default is <strong>featureTemplate</strong>).</li>\n</ul>\n<p><strong>2. Code Replacement:</strong> The task will read the template files and replace placeholders (<strong>{{featureName}}</strong>, <strong>{{className}}</strong>, and <strong>{{packageName}}</strong>) with actual values based on your project configuration.</p>\n<p><strong>3. Directory Structure:</strong> The task creates a new directory structure for the feature under <strong>src/main/java/&lt;packageName&gt;/&lt;FeatureName&gt;/</strong> and generates the required\u00a0files.</p>\n<h4>Code Implementation:</h4>\n<pre>// build.gradle.kts (Module :app)<br>tasks.register(\"moveTemplateToFeature\") {<br>    val rootFolderName = \"featureTemplate\"<br><br>    val featureName = project.findProperty(\"featureName\") as String?<br>        ?: error(\"Feature name is required. Use -PfeatureName=&lt;name&gt; to specify it.\")<br><br>    val templateName = project.findProperty(\"templateName\") as String?<br>        ?: error(\"Template name is required. Use -PtemplateName=&lt;name&gt; to specify it.\")<br><br>    // Retrieve the base package name from the project configuration<br>    val basePackageName = project.android.defaultConfig.applicationId<br>        ?: error(\"Base package could not be detected. Ensure applicationId is set in defaultConfig.\")<br><br>    // Construct the base output path for the generated files<br>    val generatedFilePath = File(projectDir, \"src/main/java/${'$'}{basePackageName.replace(\".\", \"/\")}\")<br><br>    // Map of placeholders to be replaced in template files<br>    val placeholders = mapOf(<br>        \"{{packageName}}\" to basePackageName,<br>        \"{{featureName}}\" to featureName.lowercase(),<br>        \"{{className}}\" to featureName.replaceFirstChar { it.titlecase(Locale.getDefault()) }<br>    )<br><br>    doLast {<br>        val featureDir = File(generatedFilePath, featureName.lowercase())<br>        if (featureDir.exists()) error(\"Feature '${'$'}featureName' already exists at ${'$'}{featureDir.path}.\")<br>        featureDir.mkdirs()<br><br>        val templateDir = File(rootDir, \"${'$'}rootFolderName/${'$'}templateName\")<br>        check(templateDir.exists() &amp;&amp; templateDir.isDirectory) {<br>            \"Template directory '${'$'}templateDir' not found or is not a directory.\"<br>        }<br><br>        // Copy and customize template files<br>        templateDir.walkTopDown()<br>            .filter { it.isFile }<br>            .forEach { file -&gt;<br>                val relativePath = file.relativeTo(templateDir).parent ?: \"\"<br>                val featureFileName = \"${'$'}{featureName}${'$'}{file.name}\"<br>                val targetFile = File(featureDir, \"${'$'}relativePath/${'$'}featureFileName\")<br>                targetFile.parentFile.mkdirs()<br><br>                // Read file content and replace placeholders<br>                var content = file.readText()<br>                placeholders.forEach { (key, value) -&gt;<br>                    content = content.replace(key, value)<br>                }<br>                targetFile.writeText(content)<br>                println(\"Generated file: ${'$'}{targetFile.path}\")<br>            }<br><br>        println(\"Feature '${'$'}featureName' successfully generated at ${'$'}{featureDir.path}.\")<br>    }<br>}</pre>\n<blockquote><strong>Step 2: Preparing the Template\u00a0Files</strong></blockquote>\n<p>The next step is to create the templates for the feature files. These templates will contain placeholders that will be replaced by the Gradle task during generation.</p>\n<blockquote>Template Folder Structure</blockquote>\n<p>Create a <strong>featureTemplate/</strong> directory and then a subfolder for each template type (e.g., <strong>screenTemplate</strong>). Inside the <strong>screenTemplate/</strong> folder, create the following files:</p>\n<pre>featureTemplate/<br>    \u251c\u2500\u2500 screenTemplate/<br>    \u2502   \u251c\u2500\u2500 Screen.kt<br>    \u2502   \u251c\u2500\u2500 UiState.kt<br>    \u2502   \u2514\u2500\u2500 ViewModel.kt</pre>\n<blockquote>\n<strong>Screen Template (</strong><strong>Screen.kt)</strong>\n</blockquote>\n<pre>package {{packageName}}<br><br>import androidx.compose.runtime.Composable<br><br>@Composable<br>fun {{className}}Screen() {<br>    // TODO: Implement the UI for {{className}}Screen<br>}</pre>\n<blockquote>UI State Template (<strong>UiState.kt</strong>)</blockquote>\n<pre>package {{packageName}}<br><br>data class {{className}}UiState(<br>    val message: String = \"\"<br>)<br><br>sealed class {{className}}UiEvent {<br>    object OnButtonClick : {{className}}UiEvent()<br>}</pre>\n<blockquote>ViewModel Template (<strong>ViewModel.kt</strong>)</blockquote>\n<pre>package {{packageName}}<br><br>import androidx.lifecycle.ViewModel<br>import kotlinx.coroutines.flow.MutableStateFlow<br>import kotlinx.coroutines.flow.StateFlow<br><br>class {{className}}ViewModel : ViewModel() {<br>    private val _uiState = MutableStateFlow({{className}}UiState())<br>    val uiState: StateFlow&lt;{{className}}UiState&gt; = _uiState<br><br>    fun handleEvent(event: {{className}}UiEvent) {<br>        when (event) {<br>            is {{className}}UiEvent.OnButtonClick -&gt; {<br>                _uiState.value = {{className}}UiState(\"Button Clicked!\")<br>            }<br>        }<br>    }<br>}</pre>\n<blockquote><strong>Step 3: Generating a\u00a0Feature</strong></blockquote>\n<p>Once the Gradle task and templates are set up, you can now generate new features by running a Gradle\u00a0command.</p>\n<h4>How to\u00a0Run:</h4>\n<p>Run the following command from the terminal:</p>\n<pre>./gradlew moveTemplateToFeature -PfeatureName=Home -PtemplateName=screenTemplate</pre>\n<ul>\n<li>\n<strong>featureName </strong>should be replaced with the name of the feature you want to create (e.g.,\u00a0<strong>Home</strong>).</li>\n<li>\n<strong>templateName </strong>refers to the folder where your templates are stored (e.g., <strong>screenTemplate</strong>).</li>\n</ul>\n<blockquote><strong>Generated Files</strong></blockquote>\n<p>After running the command, the following files will be generated in the appropriate location:</p>\n<pre>src/main/java/com/example/app/home/<br>    \u251c\u2500\u2500 HomeScreen.kt<br>    \u251c\u2500\u2500 HomeUiState.kt<br>    \u2514\u2500\u2500 HomeViewModel.kt</pre>\n<p>Each of these files will have the placeholders replaced with the correct feature and package names. The generated files will be ready to use, and you can implement your feature logic in\u00a0them.</p>\n<blockquote><strong>Customizations</strong></blockquote>\n<h4>1. Modify Templates</h4>\n<p>You can modify the files in the <strong>featureTemplate </strong>folder to suit your app's structure and naming conventions.</p>\n<h4>2. Add More Templates</h4>\n<p>You can create additional template folders inside <strong>featureTemplate </strong>(e.g., <strong>repositoryTemplate</strong>, <strong>serviceTemplate</strong>) and add new file generation logic in the Gradle\u00a0task.</p>\n<h4>3. Placeholder Customization</h4>\n<p>The placeholders like <strong>{{packageName}}</strong>, <strong>{{featureName}}</strong>, and <strong>{{className}}</strong> can be customized in your templates to support more dynamic replacements.</p>\n<blockquote><strong>Benefits of Using Gradle for Feature Generation</strong></blockquote>\n<ol>\n<li>\n<strong>Efficiency</strong>: Automate repetitive tasks and focus on building features.</li>\n<li>\n<strong>Consistency</strong>: Maintain a standardized file structure and naming conventions across your\u00a0project.</li>\n<li>\n<strong>Scalability</strong>: Easily add more templates or customize the Gradle task for additional features.</li>\n<li>\n<strong>Flexibility</strong>: Dynamically generate files using placeholders and templates tailored to your\u00a0needs.</li>\n</ol>\n<h4>Conclusion</h4>\n<p>Automating feature creation with Gradle tasks can significantly streamline your development workflow, especially in projects with repetitive patterns. By defining templates and customizing them dynamically, you can maintain consistency, reduce errors, and save valuable development time.</p>\n<p>This approach is particularly useful for scaling projects and ensuring that all modules adhere to your project\u2019s structure and standards. Whether you\u2019re generating screens, ViewModels, or other components, this method empowers you to focus more on logic and functionality rather than boilerplate code.</p>\n<blockquote>\n<strong>Note</strong>: If you need an example, check out my repository <strong>Screen Module Generator</strong>, where I\u2019ve implemented a complete example to showcase an <strong>e-commerce product list</strong> feature using this Gradle task. It demonstrates how the entire structure is automatically set up and customized for practical use\u00a0cases.</blockquote>\n<p><strong>Happy coding!</strong></p>\n<p>Example GitHub\u00a0Repo:</p>\n<p><a href=\"https://github.com/Coding-Meet/Screen-Module-Generator\">GitHub - Coding-Meet/Screen-Module-Generator</a></p>\n<p>If you\u2019re interested in learning more about <strong>Kotlin Multiplatform</strong> and <strong>Compose Multiplatform</strong>, check out my playlist on YouTube Channel:<br><a href=\"https://youtube.com/playlist?list=PLlSuJy9SfzvEiYH59pDDNvFJjHoYLV0MM&amp;si=DhvNC5qiYh8rXzet\"><strong>Mastering Kotlin Multiplatform with Jetpack Compose: Complete Guide in\u00a0Hindi</strong></a></p>\n<p>Thank you for reading! \ud83d\ude4c\ud83d\ude4f\u270c I hope you found this guide\u00a0useful.</p>\n<p>Don\u2019t forget to clap \ud83d\udc4f to support me and follow for more insightful articles about Android Development, Kotlin, and KMP. If you need any help related to Android, Kotlin, and KMP, I\u2019m always happy to\u00a0assist.</p>\n<h3>Explore More\u00a0Projects</h3>\n<p>If you\u2019re interested in seeing full applications built with Kotlin Multiplatform and Jetpack Compose, check out these open-source projects:</p>\n<ul>\n<li>\n<strong>News Kotlin Multiplatform App</strong> (Supports Android, iOS, Windows, macOS, Linux):<br>News KMP App is a Kotlin Compose Multiplatform (KMP) project that aims to provide a consistent news reading experience across multiple platforms, including Android, iOS, Windows, macOS, and Linux. This project leverages Kotlin\u2019s multiplatform capabilities to share code and logic while using Compose for UI, ensuring a seamless and native experience on each platform.<br>GitHub Repository: <a href=\"https://github.com/Coding-Meet/News-KMP-App\">News-KMP-App</a>\n</li>\n<li>\n<strong>Gemini AI Kotlin Multiplatform App</strong> (Supports Android, iOS, Windows, macOS, Linux, and Web):<br>Gemini AI KMP App is a Kotlin Compose Multiplatform project designed by Gemini AI where you can retrieve information from text and images in a conversational format. Additionally, it allows storing chats group-wise using SQLDelight and KStore, and facilitates changing the Gemini API key.<br>GitHub Repository: <a href=\"https://github.com/Coding-Meet/Gemini-AI-KMP-App\">Gemini-AI-KMP-App</a>\n</li>\n</ul>\n<h3>Follow me\u00a0on</h3>\n<p><a href=\"https://medium.com/@meet26\">Medium</a>\u00a0, <a href=\"https://youtube.com/@codingmeet26?si=0unoWz53pxanSpv0\">YouTube\u00a0</a>, <a href=\"https://github.com/Coding-Meet\">GitHub</a>\u00a0, <a href=\"https://www.instagram.com/codingmeet26/\">Instagram</a>\u00a0, <a href=\"https://www.linkedin.com/in/coding-meet\">LinkedIn</a>\u00a0, <a href=\"https://www.buymeacoffee.com/CodingMeet\">Buy Me a Coffee</a>\u00a0, <a href=\"https://twitter.com/CodingMeet\">Twitter</a>\u00a0, <a href=\"https://telegram.me/Meetb26\">DM Me For Freelancing Project</a></p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=cfd51373e167\" width=\"1\" height=\"1\" alt=\"\"><hr>\n<p><a href=\"https://proandroiddev.com/automate-android-feature-creation-with-gradle-cfd51373e167\">Automate Android Feature Creation with Gradle</a> was originally published in <a href=\"https://proandroiddev.com/\">ProAndroidDev</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>\n","content":"\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*uSl5aXXimCMVBQUsv26QDw.png\"></figure><p>Creating features in Android development often involves repetitive tasks like setting up screen files, UI state management, and ViewModel classes. To streamline this process, we can use a <strong>Gradle Task</strong> to automatically generate these files based on reusable templates. This article will guide you step-by-step on how to implement and use this Gradle-based solution.</p>\n<blockquote><strong>What Will Be Generated?</strong></blockquote>\n<p>For every new screen, the Gradle task will generate:</p>\n<ol>\n<li>\n<strong>&lt;ScreenName&gt;Screen.kt</strong>: A composable function that defines the screen's\u00a0UI.</li>\n<li>\n<strong>&lt;ScreenName&gt;UiState.kt</strong>: A data class representing the screen's UI state and\u00a0events.</li>\n<li>\n<strong>&lt;ScreenName&gt;ViewModel.kt</strong>: A ViewModel that manages the UI state and handles user interactions.</li>\n</ol>\n<blockquote><strong>How It\u00a0Works</strong></blockquote>\n<p>The custom Gradle task simplifies the process of generating new feature files in Android by using pre-defined templates. These templates are placed in the <strong>featureTemplate </strong>directory and are used to create new screen features with consistent structure and\u00a0code.</p>\n<blockquote>\n<strong>1</strong>. <strong>Directory Structure and Template\u00a0Files</strong>\n</blockquote>\n<p>The Gradle task looks for templates in a directory called <strong>featureTemplate</strong>. Inside this directory, you can organize different feature templates into subfolders. Each subfolder corresponds to a template type. For example, the <strong>screenTemplate </strong>subfolder will contain the basic files needed to generate a new screen, such as <strong>Screen.kt</strong>, <strong>UiState.kt</strong>, and <strong>ViewModel.kt</strong>.</p>\n<p>Example of the directory structure:</p>\n<pre>featureTemplate/<br>    \u251c\u2500\u2500 screenTemplate/<br>    \u2502   \u251c\u2500\u2500 Screen.kt<br>    \u2502   \u251c\u2500\u2500 UiState.kt<br>    \u2502   \u2514\u2500\u2500 ViewModel.kt</pre>\n<blockquote><strong>2. Generated Directory Structure</strong></blockquote>\n<p>When you run the Gradle task to generate a new feature, the task creates a new directory for the feature in your project\u2019s <strong>src/main/java/com/example/app/</strong> folder. This generated directory will contain files\u00a0like:</p>\n<pre>src/main/java/com/example/app/&lt;FeatureName&gt;/<br>    \u251c\u2500\u2500 &lt;FeatureName&gt;Screen.kt<br>    \u251c\u2500\u2500 &lt;FeatureName&gt;UiState.kt<br>    \u2514\u2500\u2500 &lt;FeatureName&gt;ViewModel.kt</pre>\n<p>For instance, if you create a feature called <strong>Home</strong>, the task will generate:</p>\n<pre>src/main/java/com/example/app/home/<br>    \u251c\u2500\u2500 HomeScreen.kt<br>    \u251c\u2500\u2500 HomeUiState.kt<br>    \u2514\u2500\u2500 HomeViewModel.kt</pre>\n<blockquote><strong>3. Template Customization</strong></blockquote>\n<p>The templates in the <strong>featureTemplate </strong>directory use placeholders like <strong>{{FeatureName}}</strong>, <strong>{{packageName}}</strong>, and <strong>{{className}}</strong>. When the Gradle task runs, these placeholders are automatically replaced with actual values based on the <strong>featureName </strong>you provide and the configuration of your\u00a0project.</p>\n<p>For example, if your feature name is <strong>Home</strong>, the template file <strong>Screen.kt</strong> might look like\u00a0this:</p>\n<p><strong>Template (Screen.kt)</strong>:</p>\n<pre>package {{packageName}}<br><br>import androidx.compose.runtime.Composable<br><br>@Composable<br>fun {{className}}Screen() {<br>    // TODO: Implement the UI for {{className}}Screen<br>}</pre>\n<p>When you run the task with <strong>-PfeatureName=Home</strong>, the task will replace <strong>{{packageName}}</strong> with your base package name (e.g., <strong>com.example.app</strong>) and <strong>{{className}}</strong> with <strong>Home</strong>. This results in the following generated file:</p>\n<p><strong>Generated (HomeScreen.kt)</strong>:</p>\n<pre>package com.example.app<br><br>import androidx.compose.runtime.Composable<br><br>@Composable<br>fun HomeScreen() {<br>    // TODO: Implement the UI for HomeScreen<br>}</pre>\n<p>This customization process ensures that each feature file is tailored to your project without manual\u00a0editing.</p>\n<blockquote>I<strong>mplementation of Feature Template Automation in Android\u00a0Project</strong>\n</blockquote>\n<p>To implement the automation of feature generation in your Android project, follow the steps outlined below. These steps will guide you in setting up the necessary Gradle task, preparing template files, and using those templates to generate new features automatically.</p>\n<blockquote><strong>Step 1: Setting Up the Gradle\u00a0Task</strong></blockquote>\n<p>The first step is to define a custom Gradle task in your <strong>build.gradle.kts</strong> file. This task will automatically generate the necessary feature files based on the template you\u00a0specify.</p>\n<h4>How It\u00a0Works:</h4>\n<ol><li>\n<strong>Defining Properties:</strong> The task will accept two properties:</li></ol>\n<ul>\n<li>\n<strong>featureName</strong>: The name of the feature you want to generate (e.g.,\u00a0<strong>Home</strong>).</li>\n<li>\n<strong>templateName</strong>: The type of template you want to use (e.g., <strong>screenTemplate</strong>).</li>\n<li>\n<strong>rootFolderName</strong>: Identifies the directory containing your template files (default is <strong>featureTemplate</strong>).</li>\n</ul>\n<p><strong>2. Code Replacement:</strong> The task will read the template files and replace placeholders (<strong>{{featureName}}</strong>, <strong>{{className}}</strong>, and <strong>{{packageName}}</strong>) with actual values based on your project configuration.</p>\n<p><strong>3. Directory Structure:</strong> The task creates a new directory structure for the feature under <strong>src/main/java/&lt;packageName&gt;/&lt;FeatureName&gt;/</strong> and generates the required\u00a0files.</p>\n<h4>Code Implementation:</h4>\n<pre>// build.gradle.kts (Module :app)<br>tasks.register(\"moveTemplateToFeature\") {<br>    val rootFolderName = \"featureTemplate\"<br><br>    val featureName = project.findProperty(\"featureName\") as String?<br>        ?: error(\"Feature name is required. Use -PfeatureName=&lt;name&gt; to specify it.\")<br><br>    val templateName = project.findProperty(\"templateName\") as String?<br>        ?: error(\"Template name is required. Use -PtemplateName=&lt;name&gt; to specify it.\")<br><br>    // Retrieve the base package name from the project configuration<br>    val basePackageName = project.android.defaultConfig.applicationId<br>        ?: error(\"Base package could not be detected. Ensure applicationId is set in defaultConfig.\")<br><br>    // Construct the base output path for the generated files<br>    val generatedFilePath = File(projectDir, \"src/main/java/${'$'}{basePackageName.replace(\".\", \"/\")}\")<br><br>    // Map of placeholders to be replaced in template files<br>    val placeholders = mapOf(<br>        \"{{packageName}}\" to basePackageName,<br>        \"{{featureName}}\" to featureName.lowercase(),<br>        \"{{className}}\" to featureName.replaceFirstChar { it.titlecase(Locale.getDefault()) }<br>    )<br><br>    doLast {<br>        val featureDir = File(generatedFilePath, featureName.lowercase())<br>        if (featureDir.exists()) error(\"Feature '${'$'}featureName' already exists at ${'$'}{featureDir.path}.\")<br>        featureDir.mkdirs()<br><br>        val templateDir = File(rootDir, \"${'$'}rootFolderName/${'$'}templateName\")<br>        check(templateDir.exists() &amp;&amp; templateDir.isDirectory) {<br>            \"Template directory '${'$'}templateDir' not found or is not a directory.\"<br>        }<br><br>        // Copy and customize template files<br>        templateDir.walkTopDown()<br>            .filter { it.isFile }<br>            .forEach { file -&gt;<br>                val relativePath = file.relativeTo(templateDir).parent ?: \"\"<br>                val featureFileName = \"${'$'}{featureName}${'$'}{file.name}\"<br>                val targetFile = File(featureDir, \"${'$'}relativePath/${'$'}featureFileName\")<br>                targetFile.parentFile.mkdirs()<br><br>                // Read file content and replace placeholders<br>                var content = file.readText()<br>                placeholders.forEach { (key, value) -&gt;<br>                    content = content.replace(key, value)<br>                }<br>                targetFile.writeText(content)<br>                println(\"Generated file: ${'$'}{targetFile.path}\")<br>            }<br><br>        println(\"Feature '${'$'}featureName' successfully generated at ${'$'}{featureDir.path}.\")<br>    }<br>}</pre>\n<blockquote><strong>Step 2: Preparing the Template\u00a0Files</strong></blockquote>\n<p>The next step is to create the templates for the feature files. These templates will contain placeholders that will be replaced by the Gradle task during generation.</p>\n<blockquote>Template Folder Structure</blockquote>\n<p>Create a <strong>featureTemplate/</strong> directory and then a subfolder for each template type (e.g., <strong>screenTemplate</strong>). Inside the <strong>screenTemplate/</strong> folder, create the following files:</p>\n<pre>featureTemplate/<br>    \u251c\u2500\u2500 screenTemplate/<br>    \u2502   \u251c\u2500\u2500 Screen.kt<br>    \u2502   \u251c\u2500\u2500 UiState.kt<br>    \u2502   \u2514\u2500\u2500 ViewModel.kt</pre>\n<blockquote>\n<strong>Screen Template (</strong><strong>Screen.kt)</strong>\n</blockquote>\n<pre>package {{packageName}}<br><br>import androidx.compose.runtime.Composable<br><br>@Composable<br>fun {{className}}Screen() {<br>    // TODO: Implement the UI for {{className}}Screen<br>}</pre>\n<blockquote>UI State Template (<strong>UiState.kt</strong>)</blockquote>\n<pre>package {{packageName}}<br><br>data class {{className}}UiState(<br>    val message: String = \"\"<br>)<br><br>sealed class {{className}}UiEvent {<br>    object OnButtonClick : {{className}}UiEvent()<br>}</pre>\n<blockquote>ViewModel Template (<strong>ViewModel.kt</strong>)</blockquote>\n<pre>package {{packageName}}<br><br>import androidx.lifecycle.ViewModel<br>import kotlinx.coroutines.flow.MutableStateFlow<br>import kotlinx.coroutines.flow.StateFlow<br><br>class {{className}}ViewModel : ViewModel() {<br>    private val _uiState = MutableStateFlow({{className}}UiState())<br>    val uiState: StateFlow&lt;{{className}}UiState&gt; = _uiState<br><br>    fun handleEvent(event: {{className}}UiEvent) {<br>        when (event) {<br>            is {{className}}UiEvent.OnButtonClick -&gt; {<br>                _uiState.value = {{className}}UiState(\"Button Clicked!\")<br>            }<br>        }<br>    }<br>}</pre>\n<blockquote><strong>Step 3: Generating a\u00a0Feature</strong></blockquote>\n<p>Once the Gradle task and templates are set up, you can now generate new features by running a Gradle\u00a0command.</p>\n<h4>How to\u00a0Run:</h4>\n<p>Run the following command from the terminal:</p>\n<pre>./gradlew moveTemplateToFeature -PfeatureName=Home -PtemplateName=screenTemplate</pre>\n<ul>\n<li>\n<strong>featureName </strong>should be replaced with the name of the feature you want to create (e.g.,\u00a0<strong>Home</strong>).</li>\n<li>\n<strong>templateName </strong>refers to the folder where your templates are stored (e.g., <strong>screenTemplate</strong>).</li>\n</ul>\n<blockquote><strong>Generated Files</strong></blockquote>\n<p>After running the command, the following files will be generated in the appropriate location:</p>\n<pre>src/main/java/com/example/app/home/<br>    \u251c\u2500\u2500 HomeScreen.kt<br>    \u251c\u2500\u2500 HomeUiState.kt<br>    \u2514\u2500\u2500 HomeViewModel.kt</pre>\n<p>Each of these files will have the placeholders replaced with the correct feature and package names. The generated files will be ready to use, and you can implement your feature logic in\u00a0them.</p>\n<blockquote><strong>Customizations</strong></blockquote>\n<h4>1. Modify Templates</h4>\n<p>You can modify the files in the <strong>featureTemplate </strong>folder to suit your app's structure and naming conventions.</p>\n<h4>2. Add More Templates</h4>\n<p>You can create additional template folders inside <strong>featureTemplate </strong>(e.g., <strong>repositoryTemplate</strong>, <strong>serviceTemplate</strong>) and add new file generation logic in the Gradle\u00a0task.</p>\n<h4>3. Placeholder Customization</h4>\n<p>The placeholders like <strong>{{packageName}}</strong>, <strong>{{featureName}}</strong>, and <strong>{{className}}</strong> can be customized in your templates to support more dynamic replacements.</p>\n<blockquote><strong>Benefits of Using Gradle for Feature Generation</strong></blockquote>\n<ol>\n<li>\n<strong>Efficiency</strong>: Automate repetitive tasks and focus on building features.</li>\n<li>\n<strong>Consistency</strong>: Maintain a standardized file structure and naming conventions across your\u00a0project.</li>\n<li>\n<strong>Scalability</strong>: Easily add more templates or customize the Gradle task for additional features.</li>\n<li>\n<strong>Flexibility</strong>: Dynamically generate files using placeholders and templates tailored to your\u00a0needs.</li>\n</ol>\n<h4>Conclusion</h4>\n<p>Automating feature creation with Gradle tasks can significantly streamline your development workflow, especially in projects with repetitive patterns. By defining templates and customizing them dynamically, you can maintain consistency, reduce errors, and save valuable development time.</p>\n<p>This approach is particularly useful for scaling projects and ensuring that all modules adhere to your project\u2019s structure and standards. Whether you\u2019re generating screens, ViewModels, or other components, this method empowers you to focus more on logic and functionality rather than boilerplate code.</p>\n<blockquote>\n<strong>Note</strong>: If you need an example, check out my repository <strong>Screen Module Generator</strong>, where I\u2019ve implemented a complete example to showcase an <strong>e-commerce product list</strong> feature using this Gradle task. It demonstrates how the entire structure is automatically set up and customized for practical use\u00a0cases.</blockquote>\n<p><strong>Happy coding!</strong></p>\n<p>Example GitHub\u00a0Repo:</p>\n<p><a href=\"https://github.com/Coding-Meet/Screen-Module-Generator\">GitHub - Coding-Meet/Screen-Module-Generator</a></p>\n<p>If you\u2019re interested in learning more about <strong>Kotlin Multiplatform</strong> and <strong>Compose Multiplatform</strong>, check out my playlist on YouTube Channel:<br><a href=\"https://youtube.com/playlist?list=PLlSuJy9SfzvEiYH59pDDNvFJjHoYLV0MM&amp;si=DhvNC5qiYh8rXzet\"><strong>Mastering Kotlin Multiplatform with Jetpack Compose: Complete Guide in\u00a0Hindi</strong></a></p>\n<p>Thank you for reading! \ud83d\ude4c\ud83d\ude4f\u270c I hope you found this guide\u00a0useful.</p>\n<p>Don\u2019t forget to clap \ud83d\udc4f to support me and follow for more insightful articles about Android Development, Kotlin, and KMP. If you need any help related to Android, Kotlin, and KMP, I\u2019m always happy to\u00a0assist.</p>\n<h3>Explore More\u00a0Projects</h3>\n<p>If you\u2019re interested in seeing full applications built with Kotlin Multiplatform and Jetpack Compose, check out these open-source projects:</p>\n<ul>\n<li>\n<strong>News Kotlin Multiplatform App</strong> (Supports Android, iOS, Windows, macOS, Linux):<br>News KMP App is a Kotlin Compose Multiplatform (KMP) project that aims to provide a consistent news reading experience across multiple platforms, including Android, iOS, Windows, macOS, and Linux. This project leverages Kotlin\u2019s multiplatform capabilities to share code and logic while using Compose for UI, ensuring a seamless and native experience on each platform.<br>GitHub Repository: <a href=\"https://github.com/Coding-Meet/News-KMP-App\">News-KMP-App</a>\n</li>\n<li>\n<strong>Gemini AI Kotlin Multiplatform App</strong> (Supports Android, iOS, Windows, macOS, Linux, and Web):<br>Gemini AI KMP App is a Kotlin Compose Multiplatform project designed by Gemini AI where you can retrieve information from text and images in a conversational format. Additionally, it allows storing chats group-wise using SQLDelight and KStore, and facilitates changing the Gemini API key.<br>GitHub Repository: <a href=\"https://github.com/Coding-Meet/Gemini-AI-KMP-App\">Gemini-AI-KMP-App</a>\n</li>\n</ul>\n<h3>Follow me\u00a0on</h3>\n<p><a href=\"https://medium.com/@meet26\">Medium</a>\u00a0, <a href=\"https://youtube.com/@codingmeet26?si=0unoWz53pxanSpv0\">YouTube\u00a0</a>, <a href=\"https://github.com/Coding-Meet\">GitHub</a>\u00a0, <a href=\"https://www.instagram.com/codingmeet26/\">Instagram</a>\u00a0, <a href=\"https://www.linkedin.com/in/coding-meet\">LinkedIn</a>\u00a0, <a href=\"https://www.buymeacoffee.com/CodingMeet\">Buy Me a Coffee</a>\u00a0, <a href=\"https://twitter.com/CodingMeet\">Twitter</a>\u00a0, <a href=\"https://telegram.me/Meetb26\">DM Me For Freelancing Project</a></p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=cfd51373e167\" width=\"1\" height=\"1\" alt=\"\"><hr>\n<p><a href=\"https://proandroiddev.com/automate-android-feature-creation-with-gradle-cfd51373e167\">Automate Android Feature Creation with Gradle</a> was originally published in <a href=\"https://proandroiddev.com/\">ProAndroidDev</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>\n","enclosure":{},"categories":["kotlin","java","android-studio","automation","gradle"]},{"title":"Full Guide: How to Form Validation With Jetpack Compose","pubDate":"2024-10-01 10:52:50","link":"https://proandroiddev.com/full-guide-how-to-form-validation-with-jetpack-compose-01e0464ae884?source=rss-b69c0e11154c------2","guid":"https://medium.com/p/01e0464ae884","author":"Meet","thumbnail":"","description":"\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*fkUvzK7YR0kTSWSwydY9XA.png\"></figure><p>In this article, we will walk you through the process of integrating form validation in an Android application using Jetpack Compose. You\u2019ll learn how to implement effective validation for fields such as name, email, password, and confirm password, enhancing the robustness of your app. By the end of this tutorial, you\u2019ll have a solid understanding of how to validate user inputs and provide immediate feedback, making your application more user-friendly and reliable.</p>\n<blockquote>Step 1: Create a <strong>UiText </strong>Interface for Dynamic Strings and Easy Localization</blockquote>\n<p>The first step in building a robust form validation system is to handle strings dynamically. This is especially useful for localization and accessing string resources. We\u2019ll create an interface called <strong>UiText </strong>that allows us to handle both dynamic strings and string resources.</p>\n<pre>sealed interface UiText {<br>    data class DynamicString(val value: String) : UiText<br>    class StringResource(<br>        @StringRes val resId: Int,<br>        vararg val args: Any<br>    ) : UiText<br><br>    @Composable<br>    fun asString(): String {<br>        return when (this) {<br>            is DynamicString -&gt; value<br>            is StringResource -&gt; stringResource(resId, *args)<br>        }<br>    }<br><br>    fun asString(context: Context): String {<br>        return when (this) {<br>            is DynamicString -&gt; value<br>            is StringResource -&gt; context.getString(resId, *args)<br>        }<br>    }<br>}</pre>\n<h4>Explanation:</h4>\n<ul>\n<li>\n<strong>DynamicString</strong>: This is used for non-resource-based strings that can be created at\u00a0runtime.</li>\n<li>\n<strong>StringResource</strong>: This handles strings from Android\u2019s <strong>strings.xml</strong> resources and allows passing arguments to format the\u00a0string.</li>\n<li>The <strong>asString()</strong> function is available in two forms: one for Compose and one for traditional Android <strong>Context</strong>, making it versatile for different use\u00a0cases.</li>\n</ul>\n<blockquote>Step 2: Create the <strong>IconResource </strong>Class for Dynamic Icon Management</blockquote>\n<p>Next, we will handle dynamic icons in a similar way. Jetpack Compose allows us to use both drawable resources and vector images. To manage these efficiently, we\u2019ll create an <strong>IconResource </strong>class that supports both resource-based and vector-based icons.</p>\n<pre>class IconResource private constructor(<br>    @DrawableRes private val resID: Int?,<br>    private val imageVector: ImageVector?<br>) {<br><br>    @Composable<br>    fun asPainterResource(): Painter {<br>        resID?.let {<br>            return painterResource(id = resID)<br>        }<br>        return rememberVectorPainter(image = imageVector!!)<br>    }<br><br>    companion object {<br>        fun fromDrawableResource(@DrawableRes resID: Int): IconResource {<br>            return IconResource(resID, null)<br>        }<br><br>        fun fromImageVector(imageVector: ImageVector): IconResource {<br>            return IconResource(null, imageVector)<br>        }<br>    }<br>}</pre>\n<h4>Explanation:</h4>\n<ul>\n<li>The <strong>IconResource</strong> class is used to handle both drawable resource-based icons and <strong>ImageVector </strong>icons in\u00a0Compose.</li>\n<li>The <strong>asPainterResource()</strong> function checks whether the icon is a drawable resource or an <strong>ImageVector</strong>, then returns the appropriate <strong>Painter </strong>to be used in\u00a0Compose.</li>\n<li>\n<strong>Factory Methods</strong>: The companion object provides factory methods: <strong>fromDrawableResource()</strong> for drawable resources and <strong>fromImageVector()</strong> for vector images, making the API easy to\u00a0use.</li>\n</ul>\n<blockquote>Step 3: Define the <strong>FieldInput </strong>and <strong>ErrorStatus </strong>Data\u00a0Classes</blockquote>\n<p>To implement form validation, we need to track both the field input and its validation status. We define two simple data classes: <strong>FieldInput </strong>for capturing the field value and whether the user has interacted with it, and <strong>ErrorStatus </strong>for capturing any validation errors.</p>\n<pre>data class FieldInput(<br>    val value: String = \"\",<br>    val hasInteracted: Boolean = false,<br>)<br><br>data class ErrorStatus(<br>    val isError: Boolean,<br>    val errorMsg: UiText? = null,<br>)</pre>\n<h4>Explanation:</h4>\n<ul>\n<li>\n<strong>value</strong>: Holds the current value of the input\u00a0field.</li>\n<li>\n<strong>hasInteracted</strong>: Tracks whether the user has interacted with the field, helping to show validation errors only after interaction.</li>\n<li>\n<strong>isError</strong>: A boolean indicating if there\u2019s an error in the\u00a0field.</li>\n<li>\n<strong>errorMsg</strong>: A <strong>UiText </strong>object that holds the error message, making it easier to display error messages dynamically or using resource\u00a0strings.</li>\n</ul>\n<blockquote>Step 4: Create the <strong>OutlineFieldWithState </strong>Composable for Input\u00a0Handling</blockquote>\n<p>Now, we need a composable function that will render an outlined text field with proper handling for errors, icons, and visibility of password fields. The <strong>OutlineFieldWithState </strong>composable helps to manage all of these aspects within a single component.</p>\n<pre>import androidx.compose.foundation.layout.fillMaxWidth<br>import androidx.compose.foundation.text.KeyboardActions<br>import androidx.compose.foundation.text.KeyboardOptions<br>import androidx.compose.material.icons.Icons<br>import androidx.compose.material.icons.filled.Info<br>import androidx.compose.material3.Icon<br>import androidx.compose.material3.IconButton<br>import androidx.compose.material3.MaterialTheme<br>import androidx.compose.material3.OutlinedTextField<br>import androidx.compose.material3.Text<br>import androidx.compose.runtime.Composable<br>import androidx.compose.runtime.getValue<br>import androidx.compose.runtime.mutableStateOf<br>import androidx.compose.runtime.remember<br>import androidx.compose.runtime.setValue<br>import androidx.compose.ui.Modifier<br>import androidx.compose.ui.res.painterResource<br>import androidx.compose.ui.text.input.PasswordVisualTransformation<br>import androidx.compose.ui.text.input.VisualTransformation<br><br><br>@Composable<br>fun OutlineFieldWithState(<br>    modifier: Modifier = Modifier,<br>    label: String,<br>    fieldInput: FieldInput,<br>    errorStatus: ErrorStatus,<br>    keyboardOptions: KeyboardOptions,<br>    isPasswordField: Boolean = false,<br>    keyboardActions: KeyboardActions = KeyboardActions.Default,<br>    leadingIconResource: IconResource? = null,<br>    onValueChange: (String) -&gt; Unit,<br>) {<br><br>    var passwordVisible by remember { mutableStateOf(false) }<br><br>    OutlinedTextField(<br>        modifier = modifier,<br>        value = fieldInput.value,<br>        onValueChange = {<br>            onValueChange(it)<br>        },<br>        label = {<br>            Text(text = label, style = MaterialTheme.typography.bodyMedium)<br>        },<br>        singleLine = true,<br>        keyboardOptions = keyboardOptions,<br>        keyboardActions = keyboardActions,<br>        leadingIcon = leadingIconResource?.let {<br>            {<br>                Icon(it.asPainterResource(), contentDescription = null)<br>            }<br>        },<br>        isError = fieldInput.hasInteracted &amp;&amp; errorStatus.isError,<br>        supportingText = {<br>            if (fieldInput.hasInteracted &amp;&amp; errorStatus.isError) {<br>                errorStatus.errorMsg?.let {<br>                    Text(<br>                        text = it.asString(), modifier = Modifier.fillMaxWidth(),<br>                        style = MaterialTheme.typography.bodySmall<br>                    )<br>                }<br>            }<br>        },<br>        trailingIcon = if (isPasswordField) {<br>            {<br>                IconButton(onClick = { passwordVisible = !passwordVisible }) {<br>                    Icon(<br>                        painter = if (passwordVisible) painterResource(R.drawable.ic_visibility)<br>                        else painterResource(R.drawable.ic_visibility_off),<br>                        contentDescription = if (passwordVisible) \"Hide password\" else \"Show password\"<br>                    )<br>                }<br>            }<br>        } else if (fieldInput.hasInteracted &amp;&amp; errorStatus.isError) {<br>            {<br>                Icon(imageVector = Icons.Filled.Info, contentDescription = null)<br>            }<br>        } else {<br>            null<br>        },<br>        visualTransformation = if (isPasswordField &amp;&amp; !passwordVisible) PasswordVisualTransformation() else VisualTransformation.None<br>    )<br>}</pre>\n<h4>Explanation:</h4>\n<ul>\n<li>\n<strong>Password Visibility</strong>: The composable includes functionality to toggle the visibility of the password field using an <strong>IconButton</strong>.</li>\n<li>\n<strong>Leading and Trailing Icons</strong>: You can pass an <strong>IconResource </strong>to add a leading icon. For password fields, a visibility toggle icon is displayed on the trailing\u00a0side.</li>\n<li>\n<strong>Error Handling</strong>: If the field has been interacted with and contains an error, the error message is displayed below the field. An error icon also appears on the trailing side of the input when appropriate.</li>\n<li>\n<strong>Keyboard Options</strong>: The function supports custom <strong>keyboardOptions </strong>and <strong>keyboardActions</strong>, allowing flexibility in input behavior.</li>\n</ul>\n<blockquote>Step 5: Add Dependencies for ViewModel and Create <strong>InputViewModel</strong>\n</blockquote>\n<p>To manage the state of our form and handle input validation, we will create a ViewModel. First, ensure you have the necessary dependency in your <strong>build.gradle.kts</strong> file:</p>\n<pre>implementation(\"androidx.lifecycle:lifecycle-viewmodel-compose:2.8.6\")</pre>\n<p>Next, we\u2019ll create the <strong>InputViewModel </strong>class that will encapsulate the logic for managing input fields and their validation statuses.</p>\n<pre>class InputViewModel : ViewModel() {<br>    // Add properties and methods to manage form inputs and validation logic<br>}</pre>\n<h4>Explanation:</h4>\n<ul>\n<li>\n<strong>ViewModel</strong>: The <strong>InputViewModel </strong>class will extend <strong>ViewModel</strong>, allowing it to survive configuration changes such as screen rotations.</li>\n<li>\n<strong>State Management</strong>: This ViewModel will hold properties for managing the state of your form inputs, including values and error statuses, which will be observed by your composables.</li>\n</ul>\n<p>In the <strong>InputScreen </strong>composable, we will initialize the <strong>InputViewModel </strong>and structure the UI using a <strong>LazyColumn </strong>inside a <strong>Scaffold </strong>for form input\u00a0layout.</p>\n<pre>@Composable<br>fun InputScreen() {<br>    val context = LocalContext.current<br>    val inputViewModel: InputViewModel = viewModel()<br><br>    Scaffold(modifier = Modifier.fillMaxSize()) { innerPadding -&gt;<br>        LazyColumn(<br>            modifier = Modifier<br>                .fillMaxSize()<br>                .padding(innerPadding),<br>            contentPadding = PaddingValues(horizontal = 10.dp),<br>            horizontalAlignment = Alignment.CenterHorizontally,<br>            verticalArrangement = Arrangement.spacedBy(10.dp, Alignment.CenterVertically)<br>        ) {<br>            // UI content here, using inputViewModel state<br>        }<br>    }<br>}</pre>\n<h4>Explanation:</h4>\n<ul>\n<li>\n<strong>ViewModel Initialization</strong>: The <strong>InputViewModel </strong>is initialized using <strong>viewModel()</strong> to manage the form\u2019s\u00a0state.</li>\n<li>\n<strong>LocalContext</strong>: The <strong>LocalContext.current</strong> is retrieved to handle context-related operations, like showing toast messages or accessing resources.</li>\n<li>\n<strong>Scaffold</strong>: A <strong>Scaffold </strong>is used as the base layout, which allows us to manage UI components like top bars, bottom bars, and the main content\u00a0area.</li>\n<li>\n<strong>LazyColumn</strong>: Inside the <strong>Scaffold</strong>, a <strong>LazyColumn </strong>is used to arrange form elements vertically. Padding and spacing are applied for better UI alignment.</li>\n</ul>\n<blockquote>Step 6: Create a Utils File and Add <strong>showToast </strong>Function and Add String Resources for Validation Messages</blockquote>\n<p>To enhance user experience, we can create a utility function for displaying toast messages throughout our application. This function can be used to show feedback to users based on their actions, such as input validation errors.</p>\n<p>Create a new Kotlin file, for example, <strong>utils.kt</strong>, and add the following code:</p>\n<pre>import android.content.Context<br>import android.widget.Toast<br><br>fun Context.showToast(message: String) {<br>    Toast.makeText(this, message, Toast.LENGTH_LONG).show()<br>}</pre>\n<h4>Explanation:</h4>\n<ul>\n<li>\n<strong>Context Extension Function</strong>: The <strong>showToast </strong>function is an extension function on <strong>Context</strong>, allowing you to call it from any context (such as an Activity or Composable) easily.</li>\n<li>\n<strong>Toast Display</strong>: It uses the <strong>Toast.makeText</strong> method to display a toast message with a duration of <strong>Toast.LENGTH_LONG</strong>, providing feedback to\u00a0users.</li>\n</ul>\n<p>after that, we\u2019ll add the string resources required for validation in the <strong>res/values/strings.xml</strong> file. These string resources will be used to display validation messages throughout the\u00a0app.</p>\n<pre>&lt;resources&gt;<br>    &lt;!-- App Name --&gt;<br>    &lt;string name=\"app_name\"&gt;Input Validation JC&lt;/string&gt;<br><br>    &lt;!-- General Validation Messages --&gt;<br>    &lt;string name=\"required\"&gt;Required&lt;/string&gt;<br><br>    &lt;!-- Email Validation --&gt;<br>    &lt;string name=\"enter_the_email\"&gt;Enter the Email&lt;/string&gt;<br>    &lt;string name=\"valid_e_mail\"&gt;Valid E-mail&lt;/string&gt;<br><br>    &lt;!-- Password Validation --&gt;<br>    &lt;string name=\"password_must_be_8_to_10_character\"&gt;Password must be 8 to 10 Characters!&lt;/string&gt;<br>    &lt;string name=\"password_don_t_match\"&gt;Password Don\\'t Match!&lt;/string&gt;<br>    &lt;string name=\"enter_the_password\"&gt;Enter the Password&lt;/string&gt;<br>    &lt;string name=\"enter_the_confirm_password\"&gt;Enter the Confirm Password&lt;/string&gt;<br><br>    &lt;!-- Name Validation --&gt;<br>    &lt;string name=\"enter_the_name\"&gt;Enter the Name&lt;/string&gt;<br><br>    &lt;!-- Submit Button --&gt;<br>    &lt;string name=\"submit\"&gt;Submit&lt;/string&gt;<br>&lt;/resources&gt;</pre>\n<h4>Explanation:</h4>\n<ul>\n<li>\n<strong>Required Field Message</strong>: The string resource for required fields is \"Required\".</li>\n<li>\n<strong>Email Validation</strong>: Strings are provided for requesting an email input and indicating invalid email\u00a0formats.</li>\n<li>\n<strong>Password Validation</strong>: Strings handle password length validation and password matching issues (such as confirmation mismatches).</li>\n<li>\n<strong>Submit Button</strong>: The submit button label is stored as a string resource for consistency and localization.</li>\n</ul>\n<blockquote>Step 7: Implement Simple Name Validation</blockquote>\n<p>In this step, we will add a simple name validation function to the <strong>utils </strong>file and demonstrate how to use it in the <strong>InputViewModel </strong>and\u00a0UI.</p>\n<blockquote>1. Add Name Validation in <strong>utils.kt\u00a0</strong>File</blockquote>\n<p>The <strong>validateName </strong>function checks if the name input is empty. If it is, it returns an <strong>ErrorStatus </strong>with a required field error\u00a0message.</p>\n<pre>fun validateName(name: String): ErrorStatus {<br>    return when {<br>        name.trim().isEmpty() -&gt; {<br>            ErrorStatus(true, UiText.StringResource(R.string.required))<br>        }<br>        else -&gt; {<br>            ErrorStatus(false)<br>        }<br>    }<br>}</pre>\n<blockquote>2. Create ViewModel for Managing Name\u00a0Input</blockquote>\n<p>In the <strong>InputViewModel</strong>, we add the state for the <strong>nameField </strong>and use the <strong>validateName </strong>function to derive the error status based on the current\u00a0input.</p>\n<pre>class InputViewModel : ViewModel() {<br><br>    // Name field<br>    var nameField by mutableStateOf(FieldInput())<br>    val nameErrorStatus by derivedStateOf {<br>        validateName(nameField.value)<br>    }<br><br>}</pre>\n<blockquote>3. Add <strong>OutlineFieldWithState </strong>to Input\u00a0Screen</blockquote>\n<p>Next, we include an <strong>OutlineFieldWithState </strong>composable in the screen, which binds the input field to the ViewModel\u2019s <strong>nameField </strong>state and displays any validation errors.</p>\n<pre>// Name UI<br>item {<br>    OutlineFieldWithState(<br>        modifier = Modifier.fillMaxWidth(),<br>        label = stringResource(R.string.enter_the_name),<br>        fieldInput = inputViewModel.nameField,<br>        errorStatus = inputViewModel.nameErrorStatus,<br>        keyboardOptions = KeyboardOptions(<br>            keyboardType = KeyboardType.Text,<br>            capitalization = KeyboardCapitalization.Words,<br>            imeAction = ImeAction.Next<br>        ),<br>    ) {<br>        inputViewModel.nameField = inputViewModel.nameField.copy(<br>            value = it,<br>            hasInteracted = true<br>        )<br>    }<br>}</pre>\n<blockquote>4. Add Button for Submission</blockquote>\n<p>Finally, we include a <strong>Button </strong>that checks for errors on submission. If there\u2019s an error, it triggers the toast message; otherwise, it shows a success\u00a0message.</p>\n<pre>item {<br>    Button(<br>        onClick = {<br>            // Name validation<br>            if (inputViewModel.nameErrorStatus.isError) {<br>                inputViewModel.nameField = inputViewModel.nameField.copy(hasInteracted = true)<br>                inputViewModel.nameErrorStatus.errorMsg?.let {<br>                    context.showToast(it.asString(context))<br>                }<br>                return@Button<br>            }<br><br>            // Success message<br>            context.showToast(\"Success\")<br>        },<br>        modifier = Modifier.fillMaxWidth()<br>    ) {<br>        Text(text = stringResource(R.string.submit))<br>    }<br>}</pre>\n<h4>Explanation:</h4>\n<ul>\n<li>\n<strong>Name Validation</strong>: The <strong>validateName </strong>function ensures the name is not empty. If it is, an error message is displayed.</li>\n<li>\n<strong>ViewModel</strong>: The <strong>InputViewModel </strong>manages the form's state and validation logic.</li>\n<li>\n<strong>Toast Messages</strong>: When an error occurs, the user receives a toast message with the error text. If the input is valid, a success message is\u00a0shown.</li>\n</ul>\n<blockquote>Step 8: Example of Email Validation</blockquote>\n<p>In this step, we\u2019ll add an email validation function in the utils file and update the <strong>InputViewModel </strong>and UI components accordingly.</p>\n<blockquote>1. Email Validation Function</blockquote>\n<p>Add the following email validation logic to the utils\u00a0file:</p>\n<pre>fun validateEmail(email: String): ErrorStatus {<br>    val emailPattern = Regex(\"[a-zA-Z\\\\d._-]+@[a-z]+\\\\.+[a-z]+\")<br>    return when {<br>        email.trim().isEmpty() -&gt; {<br>            ErrorStatus(true, UiText.StringResource(R.string.required))<br>        }<br><br>        !email.trim().matches(emailPattern) -&gt; {<br>            ErrorStatus(true, UiText.StringResource(R.string.valid_e_mail))<br>        }<br><br>        else -&gt; {<br>            ErrorStatus(false)<br>        }<br>    }<br>}</pre>\n<p><strong>Explanation</strong>:</p>\n<ul><li>The function checks if the email is empty or does not match a valid email pattern and returns an appropriate <strong>ErrorStatus</strong>.</li></ul>\n<blockquote>2. Update the <strong>InputViewModel</strong>\n</blockquote>\n<p>Extend the <strong>InputViewModel </strong>to handle the email field validation:</p>\n<pre>class InputViewModel : ViewModel() {<br>    // Name field<br>    var nameField by mutableStateOf(FieldInput())<br>    val nameErrorStatus by derivedStateOf {<br>        validateName(nameField.value)<br>    }<br><br>    // Email field<br>    var emailField by mutableStateOf(FieldInput())<br>    val emailErrorStatus by derivedStateOf {<br>        validateEmail(emailField.value)<br>    }<br>}</pre>\n<p><strong>Explanation</strong>: The <strong>emailField</strong> is added to the ViewModel, along with <strong>emailErrorStatus</strong>, which derives its value from the <strong>validateEmail </strong>function.</p>\n<blockquote>3. Add Email Input to the\u00a0UI</blockquote>\n<p>Update the UI to include an email input field and validation:</p>\n<pre>// Name UI<br>item {<br>    OutlineFieldWithState(<br>        modifier = Modifier.fillMaxWidth(),<br>        label = stringResource(R.string.enter_the_name),<br>        fieldInput = inputViewModel.nameField,<br>        errorStatus = inputViewModel.nameErrorStatus,<br>        keyboardOptions = KeyboardOptions(<br>            keyboardType = KeyboardType.Text,<br>            capitalization = KeyboardCapitalization.Words,<br>            imeAction = ImeAction.Next<br>        ),<br>    ) {<br>        inputViewModel.nameField = inputViewModel.nameField.copy(<br>            value = it,<br>            hasInteracted = true<br>        )<br>    }<br>}<br><br>// Email UI<br>item {<br>    OutlineFieldWithState(<br>        modifier = Modifier.fillMaxWidth(),<br>        label = stringResource(R.string.enter_the_email),<br>        fieldInput = inputViewModel.emailField,<br>        errorStatus = inputViewModel.emailErrorStatus,<br>        leadingIconResource = IconResource.fromImageVector(Icons.Filled.Email),<br>        keyboardOptions = KeyboardOptions(<br>            keyboardType = KeyboardType.Email,<br>            imeAction = ImeAction.Next<br>        ),<br>    ) {<br>        inputViewModel.emailField = inputViewModel.emailField.copy(<br>            value = it,<br>            hasInteracted = true<br>        )<br>    }<br>}</pre>\n<p><strong>Explanation</strong>: Two input fields are now present\u200a\u2014\u200aone for the name and one for the email. The email field uses a custom validation to check the email\u00a0format.</p>\n<blockquote>4. Button Validation Logic</blockquote>\n<p>Add logic for the submit button to validate both\u00a0fields:</p>\n<pre>item {<br>    Button(<br>        onClick = {<br>            // Name validation<br>            if (inputViewModel.nameErrorStatus.isError) {<br>                inputViewModel.nameField = inputViewModel.nameField.copy(hasInteracted = true)<br>                inputViewModel.nameErrorStatus.errorMsg?.let {<br>                    context.showToast(it.asString(context))<br>                }<br>                return@Button<br>            }<br><br>            // Email validation<br>            if (inputViewModel.emailErrorStatus.isError) {<br>                inputViewModel.emailField = inputViewModel.emailField.copy(hasInteracted = true)<br>                inputViewModel.emailErrorStatus.errorMsg?.let {<br>                    context.showToast(it.asString(context))<br>                }<br>                return@Button<br>            }<br><br>            // Success message<br>            context.showToast(\"Success\")<br>        },<br>        modifier = Modifier.fillMaxWidth()<br>    ) {<br>        Text(text = stringResource(R.string.submit))<br>    }<br>}</pre>\n<p><strong>Explanation</strong>: This ensures that both the name and email fields are validated before displaying a success\u00a0message.</p>\n<blockquote>Step 9: Example of Password Validation</blockquote>\n<p>In this step, we will add password validation in the utils file and update the <strong>InputViewModel </strong>and UI components accordingly.</p>\n<blockquote>1. Password Validation Function</blockquote>\n<p>Add the following password validation logic to the utils\u00a0file:</p>\n<pre>fun validatePassword(password: String): ErrorStatus {<br>    return when {<br>        password.trim().isEmpty() -&gt; {<br>            ErrorStatus(true, UiText.StringResource(R.string.required))<br>        }<br>        password.trim().length &lt; 8 || password.trim().length &gt; 10 -&gt; {<br>            ErrorStatus(true, UiText.StringResource(R.string.password_must_be_8_to_10_character))<br>        }<br>        else -&gt; {<br>            ErrorStatus(false)<br>        }<br>    }<br>}</pre>\n<p><strong>Explanation</strong>: This function checks if the password is empty, or if it doesn\u2019t meet the required length (8 to 10 characters), returning the appropriate <strong>ErrorStatus</strong>.</p>\n<blockquote>2. Update the <strong>InputViewModel</strong>\n</blockquote>\n<p>Extend the <strong>InputViewModel </strong>to handle the password field validation:</p>\n<pre>class InputViewModel : ViewModel() {<br>    // Name field<br>    var nameField by mutableStateOf(FieldInput())<br>    val nameErrorStatus by derivedStateOf {<br>        validateName(nameField.value)<br>    }<br><br>    // Email field<br>    var emailField by mutableStateOf(FieldInput())<br>    val emailErrorStatus by derivedStateOf {<br>        validateEmail(emailField.value)<br>    }<br><br>    // Password field<br>    var passwordField by mutableStateOf(FieldInput())<br>    val passwordErrorStatus by derivedStateOf {<br>        validatePassword(passwordField.value)<br>    }<br>}</pre>\n<p><strong>Explanation</strong>: The <strong>passwordField </strong>is added to the ViewModel, along with <strong>passwordErrorStatus</strong>, which derives its value from the <strong>validatePassword </strong>function.</p>\n<blockquote>3. Add Password Input to the\u00a0UI</blockquote>\n<p>Update the UI to include a password input field and validation:</p>\n<pre>// Name UI<br>item {<br>    OutlineFieldWithState(<br>        modifier = Modifier.fillMaxWidth(),<br>        label = stringResource(R.string.enter_the_name),<br>        fieldInput = inputViewModel.nameField,<br>        errorStatus = inputViewModel.nameErrorStatus,<br>        keyboardOptions = KeyboardOptions(<br>            keyboardType = KeyboardType.Text,<br>            capitalization = KeyboardCapitalization.Words,<br>            imeAction = ImeAction.Next<br>        ),<br>    ) {<br>        inputViewModel.nameField = inputViewModel.nameField.copy(<br>            value = it,<br>            hasInteracted = true<br>        )<br>    }<br>}<br><br>// Email UI<br>item {<br>    OutlineFieldWithState(<br>        modifier = Modifier.fillMaxWidth(),<br>        label = stringResource(R.string.enter_the_email),<br>        fieldInput = inputViewModel.emailField,<br>        errorStatus = inputViewModel.emailErrorStatus,<br>        leadingIconResource = IconResource.fromImageVector(Icons.Filled.Email),<br>        keyboardOptions = KeyboardOptions(<br>            keyboardType = KeyboardType.Email,<br>            imeAction = ImeAction.Next<br>        ),<br>    ) {<br>        inputViewModel.emailField = inputViewModel.emailField.copy(<br>            value = it,<br>            hasInteracted = true<br>        )<br>    }<br>}<br><br>// Password UI<br>item {<br>    OutlineFieldWithState(<br>        modifier = Modifier.fillMaxWidth(),<br>        label = stringResource(R.string.enter_the_password),<br>        fieldInput = inputViewModel.passwordField,<br>        errorStatus = inputViewModel.passwordErrorStatus,<br>        leadingIconResource = IconResource.fromImageVector(Icons.Filled.Lock),<br>        keyboardOptions = KeyboardOptions(<br>            keyboardType = KeyboardType.Password,<br>            imeAction = ImeAction.Next<br>        ),<br>        isPasswordField = true<br>    ) {<br>        inputViewModel.passwordField = inputViewModel.passwordField.copy(<br>            value = it,<br>            hasInteracted = true<br>        )<br>    }<br>}</pre>\n<p><strong>Explanation</strong>: A new input field is added for the password, which uses the custom password validation logic.</p>\n<blockquote>4. Button Validation Logic</blockquote>\n<p>Add the validation for the password field when the submit button is\u00a0clicked:</p>\n<pre>item {<br>    Button(<br>        onClick = {<br>            // Name validation<br>            if (inputViewModel.nameErrorStatus.isError) {<br>                inputViewModel.nameField = inputViewModel.nameField.copy(hasInteracted = true)<br>                inputViewModel.nameErrorStatus.errorMsg?.let {<br>                    context.showToast(it.asString(context))<br>                }<br>                return@Button<br>            }<br><br>            // Email validation<br>            if (inputViewModel.emailErrorStatus.isError) {<br>                inputViewModel.emailField = inputViewModel.emailField.copy(hasInteracted = true)<br>                inputViewModel.emailErrorStatus.errorMsg?.let {<br>                    context.showToast(it.asString(context))<br>                }<br>                return@Button<br>            }<br><br>            // Password validation<br>            if (inputViewModel.passwordErrorStatus.isError) {<br>                inputViewModel.passwordField = inputViewModel.passwordField.copy(hasInteracted = true)<br>                inputViewModel.passwordErrorStatus.errorMsg?.let {<br>                    context.showToast(it.asString(context))<br>                }<br>                return@Button<br>            }<br><br>            // Success message<br>            context.showToast(\"Success\")<br>        },<br>        modifier = Modifier.fillMaxWidth()<br>    ) {<br>        Text(text = stringResource(R.string.submit))<br>    }<br>}</pre>\n<p><strong>Explanation</strong>: The submit button now checks for validation errors in the name, email, and password fields before proceeding. If any errors are found, appropriate error messages are displayed.</p>\n<blockquote>Step 10: Example of Confirm Password Validation</blockquote>\n<p>In this step, we will add Confirm password validation in the utils file and update the <strong>InputViewModel </strong>and UI components accordingly.</p>\n<blockquote>1. Confirm Password Validation Function</blockquote>\n<p>Add the following Confirm password validation logic to the utils\u00a0file:</p>\n<pre>fun validateConPassword(password : String,conPassword : String) : ErrorStatus{<br>    return when {<br>        conPassword.trim().isEmpty() -&gt; {<br>            ErrorStatus(true, UiText.StringResource(R.string.required))<br>        }<br>        conPassword.trim().length &lt; 8  || conPassword.trim().length &gt; 10 -&gt; {<br>            ErrorStatus(true, UiText.StringResource(R.string.password_must_be_8_to_10_character))<br>        }<br>        password.trim() != conPassword.trim() -&gt; {<br>            ErrorStatus(true, UiText.StringResource(R.string.password_don_t_match))<br>        }<br>        else -&gt; {<br>            ErrorStatus(false)<br>        }<br>    }<br>}</pre>\n<p><strong>Explanation</strong>: This function checks if the confirm password field is empty, verifies if the length is between 8 and 10 characters, and ensures the password and confirm password match, returning an appropriate <strong>ErrorStatus</strong>.</p>\n<blockquote>2. Update the <strong><em>InputViewModel</em></strong>\n</blockquote>\n<p>Extend your <strong>InputViewModel </strong>to handle the validation for the confirm password\u00a0field:</p>\n<pre>class InputViewModel : ViewModel() {<br>    // Name field<br>    var nameField by mutableStateOf(FieldInput())<br>    val nameErrorStatus by derivedStateOf {<br>        validateName(nameField.value)<br>    }<br><br>    // Email field<br>    var emailField by mutableStateOf(FieldInput())<br>    val emailErrorStatus by derivedStateOf {<br>        validateEmail(emailField.value)<br>    }<br><br>    // Password field<br>    var passwordField by mutableStateOf(FieldInput())<br>    val passwordErrorStatus by derivedStateOf {<br>        validatePassword(passwordField.value)<br>    }<br><br>    // Confirm Password field<br>    var conPasswordField by mutableStateOf(FieldInput())<br>    val conPasswordErrorStatus by derivedStateOf {<br>        validateConPassword(passwordField.value, conPasswordField.value)<br>    }<br>}</pre>\n<p><strong>Explanation</strong>: The <strong>conPasswordField </strong>is added to the ViewModel along with <strong>conPasswordErrorStatus</strong>, which uses the <strong>validateConPassword </strong>function to derive its\u00a0value.</p>\n<blockquote>3. Add Confirm Password Input to the\u00a0UI</blockquote>\n<p>Update the UI to include a confirm password input field and validation:</p>\n<pre>// Name UI<br>item {<br>    OutlineFieldWithState(<br>        modifier = Modifier.fillMaxWidth(),<br>        label = stringResource(R.string.enter_the_name),<br>        fieldInput = inputViewModel.nameField,<br>        errorStatus = inputViewModel.nameErrorStatus,<br>        keyboardOptions = KeyboardOptions(<br>            keyboardType = KeyboardType.Text,<br>            capitalization = KeyboardCapitalization.Words,<br>            imeAction = ImeAction.Next<br>        ),<br>    ) {<br>        inputViewModel.nameField = inputViewModel.nameField.copy(<br>            value = it,<br>            hasInteracted = true<br>        )<br>    }<br>}<br><br>// Email UI<br>item {<br>    OutlineFieldWithState(<br>        modifier = Modifier.fillMaxWidth(),<br>        label = stringResource(R.string.enter_the_email),<br>        fieldInput = inputViewModel.emailField,<br>        errorStatus = inputViewModel.emailErrorStatus,<br>        leadingIconResource = IconResource.fromImageVector(Icons.Filled.Email),<br>        keyboardOptions = KeyboardOptions(<br>            keyboardType = KeyboardType.Email,<br>            imeAction = ImeAction.Next<br>        ),<br>    ) {<br>        inputViewModel.emailField = inputViewModel.emailField.copy(<br>            value = it,<br>            hasInteracted = true<br>        )<br>    }<br>}<br><br>// Password UI<br>item {<br>    OutlineFieldWithState(<br>        modifier = Modifier.fillMaxWidth(),<br>        label = stringResource(R.string.enter_the_password),<br>        fieldInput = inputViewModel.passwordField,<br>        errorStatus = inputViewModel.passwordErrorStatus,<br>        leadingIconResource = IconResource.fromImageVector(Icons.Filled.Lock),<br>        keyboardOptions = KeyboardOptions(<br>            keyboardType = KeyboardType.Password,<br>            imeAction = ImeAction.Next<br>        ),<br>        isPasswordField = true<br>    ) {<br>        inputViewModel.passwordField = inputViewModel.passwordField.copy(<br>            value = it,<br>            hasInteracted = true<br>        )<br>    }<br>}<br><br>// Confirm Password UI<br>item {<br>    OutlineFieldWithState(<br>        modifier = Modifier.fillMaxWidth(),<br>        label = stringResource(R.string.enter_the_confirm_password),<br>        fieldInput = inputViewModel.conPasswordField,<br>        errorStatus = inputViewModel.conPasswordErrorStatus,<br>        leadingIconResource = IconResource.fromImageVector(Icons.Filled.Lock),<br>        keyboardOptions = KeyboardOptions(<br>            keyboardType = KeyboardType.Password,<br>            imeAction = ImeAction.Done<br>        ),<br>        isPasswordField = true<br>    ) {<br>        inputViewModel.conPasswordField = inputViewModel.conPasswordField.copy(<br>            value = it,<br>            hasInteracted = true<br>        )<br>    }<br>}</pre>\n<p><strong>Explanation</strong>: A new input field is added for the confirm password, which uses the custom confirm password validation logic.</p>\n<blockquote>4. Button Validation Logic</blockquote>\n<p>Add the validation for the confirm password field when the submit button is\u00a0clicked:</p>\n<pre>item {<br>    Button(<br>        onClick = {<br>            // Name validation<br>            if (inputViewModel.nameErrorStatus.isError) {<br>                inputViewModel.nameField = inputViewModel.nameField.copy(hasInteracted = true)<br>                inputViewModel.nameErrorStatus.errorMsg?.let {<br>                    context.showToast(it.asString(context))<br>                }<br>                return@Button<br>            }<br><br>            // Email validation<br>            if (inputViewModel.emailErrorStatus.isError) {<br>                inputViewModel.emailField = inputViewModel.emailField.copy(hasInteracted = true)<br>                inputViewModel.emailErrorStatus.errorMsg?.let {<br>                    context.showToast(it.asString(context))<br>                }<br>                return@Button<br>            }<br><br>            // Password validation<br>            if (inputViewModel.passwordErrorStatus.isError) {<br>                inputViewModel.passwordField = inputViewModel.passwordField.copy(hasInteracted = true)<br>                inputViewModel.passwordErrorStatus.errorMsg?.let {<br>                    context.showToast(it.asString(context))<br>                }<br>                return@Button<br>            }<br><br>            // Confirm Password validation<br>            if (inputViewModel.conPasswordErrorStatus.isError) {<br>                inputViewModel.conPasswordField = inputViewModel.conPasswordField.copy(hasInteracted = true)<br>                inputViewModel.conPasswordErrorStatus.errorMsg?.let {<br>                    context.showToast(it.asString(context))<br>                }<br>                return@Button<br>            }<br><br>            // Success message<br>            context.showToast(\"Success\")<br>        },<br>        modifier = Modifier.fillMaxWidth()<br>    ) {<br>        Text(text = stringResource(R.string.submit))<br>    }<br>}</pre>\n<p><strong>Explanation</strong>: The submit button now validates all fields, including the confirm password, and displays relevant error messages if validation fails. If all validations pass, a success message is\u00a0shown.</p>\n<p>Here\u2019s your complete <strong>InputScreen </strong>implementation along with the <strong>MainActivity </strong>class. I've ensured that all the fields, including the confirm password field and the validation logic for each input, are included:</p>\n<pre>class MainActivity : ComponentActivity() {<br>    override fun onCreate(savedInstanceState: Bundle?) {<br>        super.onCreate(savedInstanceState)<br>        enableEdgeToEdge()<br>        setContent {<br>            InputValidationJCTheme {<br>                InputScreen()<br>            }<br>        }<br>    }<br>}<br><br>@Composable<br>fun InputScreen() {<br>    val context = LocalContext.current<br>    val inputViewModel: InputViewModel = viewModel()<br><br>    Scaffold(modifier = Modifier.fillMaxSize()) { innerPadding -&gt;<br>        LazyColumn(<br>            modifier = Modifier<br>                .fillMaxSize()<br>                .padding(innerPadding),<br>            contentPadding = PaddingValues(horizontal = 10.dp),<br>            horizontalAlignment = Alignment.CenterHorizontally,<br>            verticalArrangement = Arrangement.spacedBy(10.dp, Alignment.CenterVertically)<br>        ) {<br>            item {<br>                OutlineFieldWithState(<br>                    modifier = Modifier.fillMaxWidth(),<br>                    label = stringResource(R.string.enter_the_name),<br>                    fieldInput = inputViewModel.nameField,<br>                    errorStatus = inputViewModel.nameErrorStatus,<br>                    keyboardOptions = KeyboardOptions(<br>                        keyboardType = KeyboardType.Text,<br>                        capitalization = KeyboardCapitalization.Words,<br>                        imeAction = ImeAction.Next<br>                    ),<br>                ) {<br>                    inputViewModel.nameField = inputViewModel.nameField.copy(<br>                        value = it,<br>                        hasInteracted = true<br>                    )<br>                }<br>            }<br>            item {<br>                OutlineFieldWithState(<br>                    modifier = Modifier.fillMaxWidth(),<br>                    label = stringResource(R.string.enter_the_email),<br>                    fieldInput = inputViewModel.emailField,<br>                    errorStatus = inputViewModel.emailErrorStatus,<br>                    leadingIconResource = IconResource.fromImageVector(Icons.Filled.Email),<br>                    keyboardOptions = KeyboardOptions(<br>                        keyboardType = KeyboardType.Email,<br>                        imeAction = ImeAction.Next<br>                    ),<br>                ) {<br>                    inputViewModel.emailField = inputViewModel.emailField.copy(<br>                        value = it,<br>                        hasInteracted = true<br>                    )<br>                }<br>            }<br>            item {<br>                OutlineFieldWithState(<br>                    modifier = Modifier.fillMaxWidth(),<br>                    label = stringResource(R.string.enter_the_password),<br>                    fieldInput = inputViewModel.passwordField,<br>                    errorStatus = inputViewModel.passwordErrorStatus,<br>                    leadingIconResource = IconResource.fromImageVector(Icons.Filled.Lock),<br>                    keyboardOptions = KeyboardOptions(<br>                        keyboardType = KeyboardType.Password,<br>                        imeAction = ImeAction.Next<br>                    ),<br>                    isPasswordField = true<br>                ) {<br>                    inputViewModel.passwordField = inputViewModel.passwordField.copy(<br>                        value = it,<br>                        hasInteracted = true<br>                    )<br>                }<br>            }<br>            item {<br>                OutlineFieldWithState(<br>                    modifier = Modifier.fillMaxWidth(),<br>                    label = stringResource(R.string.enter_the_confirm_password),<br>                    fieldInput = inputViewModel.conPasswordField,<br>                    errorStatus = inputViewModel.conPasswordErrorStatus,<br>                    leadingIconResource = IconResource.fromImageVector(Icons.Filled.Lock),<br>                    keyboardOptions = KeyboardOptions(<br>                        keyboardType = KeyboardType.Password,<br>                        imeAction = ImeAction.Done<br>                    ),<br>                    isPasswordField = true<br>                ) {<br>                    inputViewModel.conPasswordField = inputViewModel.conPasswordField.copy(<br>                        value = it,<br>                        hasInteracted = true<br>                    )<br>                }<br>            }<br>            item {<br>                Button(<br>                    onClick = {<br>                        if (inputViewModel.nameErrorStatus.isError) {<br>                            inputViewModel.nameField = inputViewModel.nameField.copy(hasInteracted = true)<br>                            inputViewModel.nameErrorStatus.errorMsg?.let {<br>                                context.showToast(it.asString(context))<br>                            }<br>                            return@Button<br>                        }<br>                        if (inputViewModel.emailErrorStatus.isError) {<br>                            inputViewModel.emailField = inputViewModel.emailField.copy(hasInteracted = true)<br>                            inputViewModel.emailErrorStatus.errorMsg?.let {<br>                                context.showToast(it.asString(context))<br>                            }<br>                            return@Button<br>                        }<br>                        if (inputViewModel.passwordErrorStatus.isError) {<br>                            inputViewModel.passwordField = inputViewModel.passwordField.copy(hasInteracted = true)<br>                            inputViewModel.passwordErrorStatus.errorMsg?.let {<br>                                context.showToast(it.asString(context))<br>                            }<br>                            return@Button<br>                        }<br>                        if (inputViewModel.conPasswordErrorStatus.isError) {<br>                            inputViewModel.conPasswordField = inputViewModel.conPasswordField.copy(hasInteracted = true)<br>                            inputViewModel.conPasswordErrorStatus.errorMsg?.let {<br>                                context.showToast(it.asString(context))<br>                            }<br>                            return@Button<br>                        }<br><br>                        context.showToast(\"Success\")<br>                    },<br>                    modifier = Modifier.fillMaxWidth()<br>                ) {<br>                    Text(text = stringResource(R.string.submit))<br>                }<br>            }<br>        }<br>    }<br>}</pre>\n<h3>Key Points</h3>\n<ul>\n<li>The <strong>InputScreen </strong>function displays all the input fields, including <strong>name, email, password, and confirm password</strong>.</li>\n<li>Each input field utilizes the <strong>OutlineFieldWithState </strong>composable, which is presumably a custom composable for handling input fields with state management.</li>\n<li>The submit button validates each field before proceeding, showing appropriate error messages using a\u00a0toast.</li>\n<li>Ensure that the utility functions (<strong>validateName</strong>, <strong>validateEmail</strong>, <strong>validatePassword</strong>, and <strong>validateConPassword</strong>) and the <strong>InputViewModel </strong>are defined correctly to provide the necessary validation logic.</li>\n</ul>\n<h3>Conclusion</h3>\n<p>You\u2019ve successfully integrated <strong>form validation</strong> with <strong>Jetpack Compose</strong> in <strong>Android Studio</strong>. This implementation enhances your app\u2019s reliability by ensuring that user inputs are correctly validated, providing a smoother user experience. Now, you can run the app to ensure everything works smoothly and see the benefits of your validation logic in\u00a0action.</p>\n<p><strong>Happy coding!</strong></p>\n<p>Example GitHub\u00a0Repo:</p>\n<p><a href=\"https://github.com/Coding-Meet/Input-Validation-JC\">GitHub - Coding-Meet/Input-Validation-JC</a></p>\n<a href=\"https://medium.com/media/03ea2be5ab777b90e0a030ce0c9330cb/href\">https://medium.com/media/03ea2be5ab777b90e0a030ce0c9330cb/href</a><p>If you\u2019re interested in learning more about <strong>Kotlin Multiplatform</strong> and <strong>Compose Multiplatform</strong>, check out my playlist on YouTube Channel:<br><a href=\"https://youtube.com/playlist?list=PLlSuJy9SfzvEiYH59pDDNvFJjHoYLV0MM&amp;si=DhvNC5qiYh8rXzet\"><strong>Mastering Kotlin Multiplatform with Jetpack Compose: Complete Guide in\u00a0Hindi</strong></a></p>\n<p>Thank you for reading! \ud83d\ude4c\ud83d\ude4f\u270c I hope you found this guide\u00a0useful.</p>\n<p>Don\u2019t forget to clap \ud83d\udc4f to support me and follow for more insightful articles about Android Development, Kotlin, and KMP. If you need any help related to Android, Kotlin, and KMP, I\u2019m always happy to\u00a0assist.</p>\n<h3>Explore More\u00a0Projects</h3>\n<p>If you\u2019re interested in seeing full applications built with Kotlin Multiplatform and Jetpack Compose, check out these open-source projects:</p>\n<ul>\n<li>\n<strong>News Kotlin Multiplatform App</strong> (Supports Android, iOS, Windows, macOS, Linux):<br>News KMP App is a Kotlin Compose Multiplatform (KMP) project that aims to provide a consistent news reading experience across multiple platforms, including Android, iOS, Windows, macOS, and Linux. This project leverages Kotlin\u2019s multiplatform capabilities to share code and logic while using Compose for UI, ensuring a seamless and native experience on each platform.<br>GitHub Repository: <a href=\"https://github.com/Coding-Meet/News-KMP-App\">News-KMP-App</a>\n</li>\n<li>\n<strong>Gemini AI Kotlin Multiplatform App</strong> (Supports Android, iOS, Windows, macOS, Linux, and Web):<br>Gemini AI KMP App is a Kotlin Compose Multiplatform project designed by Gemini AI where you can retrieve information from text and images in a conversational format. Additionally, it allows storing chats group-wise using SQLDelight and KStore, and facilitates changing the Gemini API key.<br>GitHub Repository: <a href=\"https://github.com/Coding-Meet/Gemini-AI-KMP-App\">Gemini-AI-KMP-App</a>\n</li>\n</ul>\n<h3>Follow me\u00a0on</h3>\n<p><a href=\"https://medium.com/@meet26\">Medium</a>\u00a0, <a href=\"https://youtube.com/@codingmeet26?si=0unoWz53pxanSpv0\">YouTube\u00a0</a>, <a href=\"https://github.com/Coding-Meet\">GitHub</a>\u00a0, <a href=\"https://www.instagram.com/codingmeet26/\">Instagram</a>\u00a0, <a href=\"https://www.linkedin.com/in/coding-meet\">LinkedIn</a>\u00a0, <a href=\"https://www.buymeacoffee.com/CodingMeet\">Buy Me a Coffee</a>\u00a0, <a href=\"https://twitter.com/CodingMeet\">Twitter</a>\u00a0, <a href=\"https://telegram.me/Meetb26\">DM Me For Freelancing Project</a></p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=01e0464ae884\" width=\"1\" height=\"1\" alt=\"\"><hr>\n<p><a href=\"https://proandroiddev.com/full-guide-how-to-form-validation-with-jetpack-compose-01e0464ae884\">Full Guide: How to Form Validation With Jetpack Compose</a> was originally published in <a href=\"https://proandroiddev.com/\">ProAndroidDev</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>\n","content":"\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*fkUvzK7YR0kTSWSwydY9XA.png\"></figure><p>In this article, we will walk you through the process of integrating form validation in an Android application using Jetpack Compose. You\u2019ll learn how to implement effective validation for fields such as name, email, password, and confirm password, enhancing the robustness of your app. By the end of this tutorial, you\u2019ll have a solid understanding of how to validate user inputs and provide immediate feedback, making your application more user-friendly and reliable.</p>\n<blockquote>Step 1: Create a <strong>UiText </strong>Interface for Dynamic Strings and Easy Localization</blockquote>\n<p>The first step in building a robust form validation system is to handle strings dynamically. This is especially useful for localization and accessing string resources. We\u2019ll create an interface called <strong>UiText </strong>that allows us to handle both dynamic strings and string resources.</p>\n<pre>sealed interface UiText {<br>    data class DynamicString(val value: String) : UiText<br>    class StringResource(<br>        @StringRes val resId: Int,<br>        vararg val args: Any<br>    ) : UiText<br><br>    @Composable<br>    fun asString(): String {<br>        return when (this) {<br>            is DynamicString -&gt; value<br>            is StringResource -&gt; stringResource(resId, *args)<br>        }<br>    }<br><br>    fun asString(context: Context): String {<br>        return when (this) {<br>            is DynamicString -&gt; value<br>            is StringResource -&gt; context.getString(resId, *args)<br>        }<br>    }<br>}</pre>\n<h4>Explanation:</h4>\n<ul>\n<li>\n<strong>DynamicString</strong>: This is used for non-resource-based strings that can be created at\u00a0runtime.</li>\n<li>\n<strong>StringResource</strong>: This handles strings from Android\u2019s <strong>strings.xml</strong> resources and allows passing arguments to format the\u00a0string.</li>\n<li>The <strong>asString()</strong> function is available in two forms: one for Compose and one for traditional Android <strong>Context</strong>, making it versatile for different use\u00a0cases.</li>\n</ul>\n<blockquote>Step 2: Create the <strong>IconResource </strong>Class for Dynamic Icon Management</blockquote>\n<p>Next, we will handle dynamic icons in a similar way. Jetpack Compose allows us to use both drawable resources and vector images. To manage these efficiently, we\u2019ll create an <strong>IconResource </strong>class that supports both resource-based and vector-based icons.</p>\n<pre>class IconResource private constructor(<br>    @DrawableRes private val resID: Int?,<br>    private val imageVector: ImageVector?<br>) {<br><br>    @Composable<br>    fun asPainterResource(): Painter {<br>        resID?.let {<br>            return painterResource(id = resID)<br>        }<br>        return rememberVectorPainter(image = imageVector!!)<br>    }<br><br>    companion object {<br>        fun fromDrawableResource(@DrawableRes resID: Int): IconResource {<br>            return IconResource(resID, null)<br>        }<br><br>        fun fromImageVector(imageVector: ImageVector): IconResource {<br>            return IconResource(null, imageVector)<br>        }<br>    }<br>}</pre>\n<h4>Explanation:</h4>\n<ul>\n<li>The <strong>IconResource</strong> class is used to handle both drawable resource-based icons and <strong>ImageVector </strong>icons in\u00a0Compose.</li>\n<li>The <strong>asPainterResource()</strong> function checks whether the icon is a drawable resource or an <strong>ImageVector</strong>, then returns the appropriate <strong>Painter </strong>to be used in\u00a0Compose.</li>\n<li>\n<strong>Factory Methods</strong>: The companion object provides factory methods: <strong>fromDrawableResource()</strong> for drawable resources and <strong>fromImageVector()</strong> for vector images, making the API easy to\u00a0use.</li>\n</ul>\n<blockquote>Step 3: Define the <strong>FieldInput </strong>and <strong>ErrorStatus </strong>Data\u00a0Classes</blockquote>\n<p>To implement form validation, we need to track both the field input and its validation status. We define two simple data classes: <strong>FieldInput </strong>for capturing the field value and whether the user has interacted with it, and <strong>ErrorStatus </strong>for capturing any validation errors.</p>\n<pre>data class FieldInput(<br>    val value: String = \"\",<br>    val hasInteracted: Boolean = false,<br>)<br><br>data class ErrorStatus(<br>    val isError: Boolean,<br>    val errorMsg: UiText? = null,<br>)</pre>\n<h4>Explanation:</h4>\n<ul>\n<li>\n<strong>value</strong>: Holds the current value of the input\u00a0field.</li>\n<li>\n<strong>hasInteracted</strong>: Tracks whether the user has interacted with the field, helping to show validation errors only after interaction.</li>\n<li>\n<strong>isError</strong>: A boolean indicating if there\u2019s an error in the\u00a0field.</li>\n<li>\n<strong>errorMsg</strong>: A <strong>UiText </strong>object that holds the error message, making it easier to display error messages dynamically or using resource\u00a0strings.</li>\n</ul>\n<blockquote>Step 4: Create the <strong>OutlineFieldWithState </strong>Composable for Input\u00a0Handling</blockquote>\n<p>Now, we need a composable function that will render an outlined text field with proper handling for errors, icons, and visibility of password fields. The <strong>OutlineFieldWithState </strong>composable helps to manage all of these aspects within a single component.</p>\n<pre>import androidx.compose.foundation.layout.fillMaxWidth<br>import androidx.compose.foundation.text.KeyboardActions<br>import androidx.compose.foundation.text.KeyboardOptions<br>import androidx.compose.material.icons.Icons<br>import androidx.compose.material.icons.filled.Info<br>import androidx.compose.material3.Icon<br>import androidx.compose.material3.IconButton<br>import androidx.compose.material3.MaterialTheme<br>import androidx.compose.material3.OutlinedTextField<br>import androidx.compose.material3.Text<br>import androidx.compose.runtime.Composable<br>import androidx.compose.runtime.getValue<br>import androidx.compose.runtime.mutableStateOf<br>import androidx.compose.runtime.remember<br>import androidx.compose.runtime.setValue<br>import androidx.compose.ui.Modifier<br>import androidx.compose.ui.res.painterResource<br>import androidx.compose.ui.text.input.PasswordVisualTransformation<br>import androidx.compose.ui.text.input.VisualTransformation<br><br><br>@Composable<br>fun OutlineFieldWithState(<br>    modifier: Modifier = Modifier,<br>    label: String,<br>    fieldInput: FieldInput,<br>    errorStatus: ErrorStatus,<br>    keyboardOptions: KeyboardOptions,<br>    isPasswordField: Boolean = false,<br>    keyboardActions: KeyboardActions = KeyboardActions.Default,<br>    leadingIconResource: IconResource? = null,<br>    onValueChange: (String) -&gt; Unit,<br>) {<br><br>    var passwordVisible by remember { mutableStateOf(false) }<br><br>    OutlinedTextField(<br>        modifier = modifier,<br>        value = fieldInput.value,<br>        onValueChange = {<br>            onValueChange(it)<br>        },<br>        label = {<br>            Text(text = label, style = MaterialTheme.typography.bodyMedium)<br>        },<br>        singleLine = true,<br>        keyboardOptions = keyboardOptions,<br>        keyboardActions = keyboardActions,<br>        leadingIcon = leadingIconResource?.let {<br>            {<br>                Icon(it.asPainterResource(), contentDescription = null)<br>            }<br>        },<br>        isError = fieldInput.hasInteracted &amp;&amp; errorStatus.isError,<br>        supportingText = {<br>            if (fieldInput.hasInteracted &amp;&amp; errorStatus.isError) {<br>                errorStatus.errorMsg?.let {<br>                    Text(<br>                        text = it.asString(), modifier = Modifier.fillMaxWidth(),<br>                        style = MaterialTheme.typography.bodySmall<br>                    )<br>                }<br>            }<br>        },<br>        trailingIcon = if (isPasswordField) {<br>            {<br>                IconButton(onClick = { passwordVisible = !passwordVisible }) {<br>                    Icon(<br>                        painter = if (passwordVisible) painterResource(R.drawable.ic_visibility)<br>                        else painterResource(R.drawable.ic_visibility_off),<br>                        contentDescription = if (passwordVisible) \"Hide password\" else \"Show password\"<br>                    )<br>                }<br>            }<br>        } else if (fieldInput.hasInteracted &amp;&amp; errorStatus.isError) {<br>            {<br>                Icon(imageVector = Icons.Filled.Info, contentDescription = null)<br>            }<br>        } else {<br>            null<br>        },<br>        visualTransformation = if (isPasswordField &amp;&amp; !passwordVisible) PasswordVisualTransformation() else VisualTransformation.None<br>    )<br>}</pre>\n<h4>Explanation:</h4>\n<ul>\n<li>\n<strong>Password Visibility</strong>: The composable includes functionality to toggle the visibility of the password field using an <strong>IconButton</strong>.</li>\n<li>\n<strong>Leading and Trailing Icons</strong>: You can pass an <strong>IconResource </strong>to add a leading icon. For password fields, a visibility toggle icon is displayed on the trailing\u00a0side.</li>\n<li>\n<strong>Error Handling</strong>: If the field has been interacted with and contains an error, the error message is displayed below the field. An error icon also appears on the trailing side of the input when appropriate.</li>\n<li>\n<strong>Keyboard Options</strong>: The function supports custom <strong>keyboardOptions </strong>and <strong>keyboardActions</strong>, allowing flexibility in input behavior.</li>\n</ul>\n<blockquote>Step 5: Add Dependencies for ViewModel and Create <strong>InputViewModel</strong>\n</blockquote>\n<p>To manage the state of our form and handle input validation, we will create a ViewModel. First, ensure you have the necessary dependency in your <strong>build.gradle.kts</strong> file:</p>\n<pre>implementation(\"androidx.lifecycle:lifecycle-viewmodel-compose:2.8.6\")</pre>\n<p>Next, we\u2019ll create the <strong>InputViewModel </strong>class that will encapsulate the logic for managing input fields and their validation statuses.</p>\n<pre>class InputViewModel : ViewModel() {<br>    // Add properties and methods to manage form inputs and validation logic<br>}</pre>\n<h4>Explanation:</h4>\n<ul>\n<li>\n<strong>ViewModel</strong>: The <strong>InputViewModel </strong>class will extend <strong>ViewModel</strong>, allowing it to survive configuration changes such as screen rotations.</li>\n<li>\n<strong>State Management</strong>: This ViewModel will hold properties for managing the state of your form inputs, including values and error statuses, which will be observed by your composables.</li>\n</ul>\n<p>In the <strong>InputScreen </strong>composable, we will initialize the <strong>InputViewModel </strong>and structure the UI using a <strong>LazyColumn </strong>inside a <strong>Scaffold </strong>for form input\u00a0layout.</p>\n<pre>@Composable<br>fun InputScreen() {<br>    val context = LocalContext.current<br>    val inputViewModel: InputViewModel = viewModel()<br><br>    Scaffold(modifier = Modifier.fillMaxSize()) { innerPadding -&gt;<br>        LazyColumn(<br>            modifier = Modifier<br>                .fillMaxSize()<br>                .padding(innerPadding),<br>            contentPadding = PaddingValues(horizontal = 10.dp),<br>            horizontalAlignment = Alignment.CenterHorizontally,<br>            verticalArrangement = Arrangement.spacedBy(10.dp, Alignment.CenterVertically)<br>        ) {<br>            // UI content here, using inputViewModel state<br>        }<br>    }<br>}</pre>\n<h4>Explanation:</h4>\n<ul>\n<li>\n<strong>ViewModel Initialization</strong>: The <strong>InputViewModel </strong>is initialized using <strong>viewModel()</strong> to manage the form\u2019s\u00a0state.</li>\n<li>\n<strong>LocalContext</strong>: The <strong>LocalContext.current</strong> is retrieved to handle context-related operations, like showing toast messages or accessing resources.</li>\n<li>\n<strong>Scaffold</strong>: A <strong>Scaffold </strong>is used as the base layout, which allows us to manage UI components like top bars, bottom bars, and the main content\u00a0area.</li>\n<li>\n<strong>LazyColumn</strong>: Inside the <strong>Scaffold</strong>, a <strong>LazyColumn </strong>is used to arrange form elements vertically. Padding and spacing are applied for better UI alignment.</li>\n</ul>\n<blockquote>Step 6: Create a Utils File and Add <strong>showToast </strong>Function and Add String Resources for Validation Messages</blockquote>\n<p>To enhance user experience, we can create a utility function for displaying toast messages throughout our application. This function can be used to show feedback to users based on their actions, such as input validation errors.</p>\n<p>Create a new Kotlin file, for example, <strong>utils.kt</strong>, and add the following code:</p>\n<pre>import android.content.Context<br>import android.widget.Toast<br><br>fun Context.showToast(message: String) {<br>    Toast.makeText(this, message, Toast.LENGTH_LONG).show()<br>}</pre>\n<h4>Explanation:</h4>\n<ul>\n<li>\n<strong>Context Extension Function</strong>: The <strong>showToast </strong>function is an extension function on <strong>Context</strong>, allowing you to call it from any context (such as an Activity or Composable) easily.</li>\n<li>\n<strong>Toast Display</strong>: It uses the <strong>Toast.makeText</strong> method to display a toast message with a duration of <strong>Toast.LENGTH_LONG</strong>, providing feedback to\u00a0users.</li>\n</ul>\n<p>after that, we\u2019ll add the string resources required for validation in the <strong>res/values/strings.xml</strong> file. These string resources will be used to display validation messages throughout the\u00a0app.</p>\n<pre>&lt;resources&gt;<br>    &lt;!-- App Name --&gt;<br>    &lt;string name=\"app_name\"&gt;Input Validation JC&lt;/string&gt;<br><br>    &lt;!-- General Validation Messages --&gt;<br>    &lt;string name=\"required\"&gt;Required&lt;/string&gt;<br><br>    &lt;!-- Email Validation --&gt;<br>    &lt;string name=\"enter_the_email\"&gt;Enter the Email&lt;/string&gt;<br>    &lt;string name=\"valid_e_mail\"&gt;Valid E-mail&lt;/string&gt;<br><br>    &lt;!-- Password Validation --&gt;<br>    &lt;string name=\"password_must_be_8_to_10_character\"&gt;Password must be 8 to 10 Characters!&lt;/string&gt;<br>    &lt;string name=\"password_don_t_match\"&gt;Password Don\\'t Match!&lt;/string&gt;<br>    &lt;string name=\"enter_the_password\"&gt;Enter the Password&lt;/string&gt;<br>    &lt;string name=\"enter_the_confirm_password\"&gt;Enter the Confirm Password&lt;/string&gt;<br><br>    &lt;!-- Name Validation --&gt;<br>    &lt;string name=\"enter_the_name\"&gt;Enter the Name&lt;/string&gt;<br><br>    &lt;!-- Submit Button --&gt;<br>    &lt;string name=\"submit\"&gt;Submit&lt;/string&gt;<br>&lt;/resources&gt;</pre>\n<h4>Explanation:</h4>\n<ul>\n<li>\n<strong>Required Field Message</strong>: The string resource for required fields is \"Required\".</li>\n<li>\n<strong>Email Validation</strong>: Strings are provided for requesting an email input and indicating invalid email\u00a0formats.</li>\n<li>\n<strong>Password Validation</strong>: Strings handle password length validation and password matching issues (such as confirmation mismatches).</li>\n<li>\n<strong>Submit Button</strong>: The submit button label is stored as a string resource for consistency and localization.</li>\n</ul>\n<blockquote>Step 7: Implement Simple Name Validation</blockquote>\n<p>In this step, we will add a simple name validation function to the <strong>utils </strong>file and demonstrate how to use it in the <strong>InputViewModel </strong>and\u00a0UI.</p>\n<blockquote>1. Add Name Validation in <strong>utils.kt\u00a0</strong>File</blockquote>\n<p>The <strong>validateName </strong>function checks if the name input is empty. If it is, it returns an <strong>ErrorStatus </strong>with a required field error\u00a0message.</p>\n<pre>fun validateName(name: String): ErrorStatus {<br>    return when {<br>        name.trim().isEmpty() -&gt; {<br>            ErrorStatus(true, UiText.StringResource(R.string.required))<br>        }<br>        else -&gt; {<br>            ErrorStatus(false)<br>        }<br>    }<br>}</pre>\n<blockquote>2. Create ViewModel for Managing Name\u00a0Input</blockquote>\n<p>In the <strong>InputViewModel</strong>, we add the state for the <strong>nameField </strong>and use the <strong>validateName </strong>function to derive the error status based on the current\u00a0input.</p>\n<pre>class InputViewModel : ViewModel() {<br><br>    // Name field<br>    var nameField by mutableStateOf(FieldInput())<br>    val nameErrorStatus by derivedStateOf {<br>        validateName(nameField.value)<br>    }<br><br>}</pre>\n<blockquote>3. Add <strong>OutlineFieldWithState </strong>to Input\u00a0Screen</blockquote>\n<p>Next, we include an <strong>OutlineFieldWithState </strong>composable in the screen, which binds the input field to the ViewModel\u2019s <strong>nameField </strong>state and displays any validation errors.</p>\n<pre>// Name UI<br>item {<br>    OutlineFieldWithState(<br>        modifier = Modifier.fillMaxWidth(),<br>        label = stringResource(R.string.enter_the_name),<br>        fieldInput = inputViewModel.nameField,<br>        errorStatus = inputViewModel.nameErrorStatus,<br>        keyboardOptions = KeyboardOptions(<br>            keyboardType = KeyboardType.Text,<br>            capitalization = KeyboardCapitalization.Words,<br>            imeAction = ImeAction.Next<br>        ),<br>    ) {<br>        inputViewModel.nameField = inputViewModel.nameField.copy(<br>            value = it,<br>            hasInteracted = true<br>        )<br>    }<br>}</pre>\n<blockquote>4. Add Button for Submission</blockquote>\n<p>Finally, we include a <strong>Button </strong>that checks for errors on submission. If there\u2019s an error, it triggers the toast message; otherwise, it shows a success\u00a0message.</p>\n<pre>item {<br>    Button(<br>        onClick = {<br>            // Name validation<br>            if (inputViewModel.nameErrorStatus.isError) {<br>                inputViewModel.nameField = inputViewModel.nameField.copy(hasInteracted = true)<br>                inputViewModel.nameErrorStatus.errorMsg?.let {<br>                    context.showToast(it.asString(context))<br>                }<br>                return@Button<br>            }<br><br>            // Success message<br>            context.showToast(\"Success\")<br>        },<br>        modifier = Modifier.fillMaxWidth()<br>    ) {<br>        Text(text = stringResource(R.string.submit))<br>    }<br>}</pre>\n<h4>Explanation:</h4>\n<ul>\n<li>\n<strong>Name Validation</strong>: The <strong>validateName </strong>function ensures the name is not empty. If it is, an error message is displayed.</li>\n<li>\n<strong>ViewModel</strong>: The <strong>InputViewModel </strong>manages the form's state and validation logic.</li>\n<li>\n<strong>Toast Messages</strong>: When an error occurs, the user receives a toast message with the error text. If the input is valid, a success message is\u00a0shown.</li>\n</ul>\n<blockquote>Step 8: Example of Email Validation</blockquote>\n<p>In this step, we\u2019ll add an email validation function in the utils file and update the <strong>InputViewModel </strong>and UI components accordingly.</p>\n<blockquote>1. Email Validation Function</blockquote>\n<p>Add the following email validation logic to the utils\u00a0file:</p>\n<pre>fun validateEmail(email: String): ErrorStatus {<br>    val emailPattern = Regex(\"[a-zA-Z\\\\d._-]+@[a-z]+\\\\.+[a-z]+\")<br>    return when {<br>        email.trim().isEmpty() -&gt; {<br>            ErrorStatus(true, UiText.StringResource(R.string.required))<br>        }<br><br>        !email.trim().matches(emailPattern) -&gt; {<br>            ErrorStatus(true, UiText.StringResource(R.string.valid_e_mail))<br>        }<br><br>        else -&gt; {<br>            ErrorStatus(false)<br>        }<br>    }<br>}</pre>\n<p><strong>Explanation</strong>:</p>\n<ul><li>The function checks if the email is empty or does not match a valid email pattern and returns an appropriate <strong>ErrorStatus</strong>.</li></ul>\n<blockquote>2. Update the <strong>InputViewModel</strong>\n</blockquote>\n<p>Extend the <strong>InputViewModel </strong>to handle the email field validation:</p>\n<pre>class InputViewModel : ViewModel() {<br>    // Name field<br>    var nameField by mutableStateOf(FieldInput())<br>    val nameErrorStatus by derivedStateOf {<br>        validateName(nameField.value)<br>    }<br><br>    // Email field<br>    var emailField by mutableStateOf(FieldInput())<br>    val emailErrorStatus by derivedStateOf {<br>        validateEmail(emailField.value)<br>    }<br>}</pre>\n<p><strong>Explanation</strong>: The <strong>emailField</strong> is added to the ViewModel, along with <strong>emailErrorStatus</strong>, which derives its value from the <strong>validateEmail </strong>function.</p>\n<blockquote>3. Add Email Input to the\u00a0UI</blockquote>\n<p>Update the UI to include an email input field and validation:</p>\n<pre>// Name UI<br>item {<br>    OutlineFieldWithState(<br>        modifier = Modifier.fillMaxWidth(),<br>        label = stringResource(R.string.enter_the_name),<br>        fieldInput = inputViewModel.nameField,<br>        errorStatus = inputViewModel.nameErrorStatus,<br>        keyboardOptions = KeyboardOptions(<br>            keyboardType = KeyboardType.Text,<br>            capitalization = KeyboardCapitalization.Words,<br>            imeAction = ImeAction.Next<br>        ),<br>    ) {<br>        inputViewModel.nameField = inputViewModel.nameField.copy(<br>            value = it,<br>            hasInteracted = true<br>        )<br>    }<br>}<br><br>// Email UI<br>item {<br>    OutlineFieldWithState(<br>        modifier = Modifier.fillMaxWidth(),<br>        label = stringResource(R.string.enter_the_email),<br>        fieldInput = inputViewModel.emailField,<br>        errorStatus = inputViewModel.emailErrorStatus,<br>        leadingIconResource = IconResource.fromImageVector(Icons.Filled.Email),<br>        keyboardOptions = KeyboardOptions(<br>            keyboardType = KeyboardType.Email,<br>            imeAction = ImeAction.Next<br>        ),<br>    ) {<br>        inputViewModel.emailField = inputViewModel.emailField.copy(<br>            value = it,<br>            hasInteracted = true<br>        )<br>    }<br>}</pre>\n<p><strong>Explanation</strong>: Two input fields are now present\u200a\u2014\u200aone for the name and one for the email. The email field uses a custom validation to check the email\u00a0format.</p>\n<blockquote>4. Button Validation Logic</blockquote>\n<p>Add logic for the submit button to validate both\u00a0fields:</p>\n<pre>item {<br>    Button(<br>        onClick = {<br>            // Name validation<br>            if (inputViewModel.nameErrorStatus.isError) {<br>                inputViewModel.nameField = inputViewModel.nameField.copy(hasInteracted = true)<br>                inputViewModel.nameErrorStatus.errorMsg?.let {<br>                    context.showToast(it.asString(context))<br>                }<br>                return@Button<br>            }<br><br>            // Email validation<br>            if (inputViewModel.emailErrorStatus.isError) {<br>                inputViewModel.emailField = inputViewModel.emailField.copy(hasInteracted = true)<br>                inputViewModel.emailErrorStatus.errorMsg?.let {<br>                    context.showToast(it.asString(context))<br>                }<br>                return@Button<br>            }<br><br>            // Success message<br>            context.showToast(\"Success\")<br>        },<br>        modifier = Modifier.fillMaxWidth()<br>    ) {<br>        Text(text = stringResource(R.string.submit))<br>    }<br>}</pre>\n<p><strong>Explanation</strong>: This ensures that both the name and email fields are validated before displaying a success\u00a0message.</p>\n<blockquote>Step 9: Example of Password Validation</blockquote>\n<p>In this step, we will add password validation in the utils file and update the <strong>InputViewModel </strong>and UI components accordingly.</p>\n<blockquote>1. Password Validation Function</blockquote>\n<p>Add the following password validation logic to the utils\u00a0file:</p>\n<pre>fun validatePassword(password: String): ErrorStatus {<br>    return when {<br>        password.trim().isEmpty() -&gt; {<br>            ErrorStatus(true, UiText.StringResource(R.string.required))<br>        }<br>        password.trim().length &lt; 8 || password.trim().length &gt; 10 -&gt; {<br>            ErrorStatus(true, UiText.StringResource(R.string.password_must_be_8_to_10_character))<br>        }<br>        else -&gt; {<br>            ErrorStatus(false)<br>        }<br>    }<br>}</pre>\n<p><strong>Explanation</strong>: This function checks if the password is empty, or if it doesn\u2019t meet the required length (8 to 10 characters), returning the appropriate <strong>ErrorStatus</strong>.</p>\n<blockquote>2. Update the <strong>InputViewModel</strong>\n</blockquote>\n<p>Extend the <strong>InputViewModel </strong>to handle the password field validation:</p>\n<pre>class InputViewModel : ViewModel() {<br>    // Name field<br>    var nameField by mutableStateOf(FieldInput())<br>    val nameErrorStatus by derivedStateOf {<br>        validateName(nameField.value)<br>    }<br><br>    // Email field<br>    var emailField by mutableStateOf(FieldInput())<br>    val emailErrorStatus by derivedStateOf {<br>        validateEmail(emailField.value)<br>    }<br><br>    // Password field<br>    var passwordField by mutableStateOf(FieldInput())<br>    val passwordErrorStatus by derivedStateOf {<br>        validatePassword(passwordField.value)<br>    }<br>}</pre>\n<p><strong>Explanation</strong>: The <strong>passwordField </strong>is added to the ViewModel, along with <strong>passwordErrorStatus</strong>, which derives its value from the <strong>validatePassword </strong>function.</p>\n<blockquote>3. Add Password Input to the\u00a0UI</blockquote>\n<p>Update the UI to include a password input field and validation:</p>\n<pre>// Name UI<br>item {<br>    OutlineFieldWithState(<br>        modifier = Modifier.fillMaxWidth(),<br>        label = stringResource(R.string.enter_the_name),<br>        fieldInput = inputViewModel.nameField,<br>        errorStatus = inputViewModel.nameErrorStatus,<br>        keyboardOptions = KeyboardOptions(<br>            keyboardType = KeyboardType.Text,<br>            capitalization = KeyboardCapitalization.Words,<br>            imeAction = ImeAction.Next<br>        ),<br>    ) {<br>        inputViewModel.nameField = inputViewModel.nameField.copy(<br>            value = it,<br>            hasInteracted = true<br>        )<br>    }<br>}<br><br>// Email UI<br>item {<br>    OutlineFieldWithState(<br>        modifier = Modifier.fillMaxWidth(),<br>        label = stringResource(R.string.enter_the_email),<br>        fieldInput = inputViewModel.emailField,<br>        errorStatus = inputViewModel.emailErrorStatus,<br>        leadingIconResource = IconResource.fromImageVector(Icons.Filled.Email),<br>        keyboardOptions = KeyboardOptions(<br>            keyboardType = KeyboardType.Email,<br>            imeAction = ImeAction.Next<br>        ),<br>    ) {<br>        inputViewModel.emailField = inputViewModel.emailField.copy(<br>            value = it,<br>            hasInteracted = true<br>        )<br>    }<br>}<br><br>// Password UI<br>item {<br>    OutlineFieldWithState(<br>        modifier = Modifier.fillMaxWidth(),<br>        label = stringResource(R.string.enter_the_password),<br>        fieldInput = inputViewModel.passwordField,<br>        errorStatus = inputViewModel.passwordErrorStatus,<br>        leadingIconResource = IconResource.fromImageVector(Icons.Filled.Lock),<br>        keyboardOptions = KeyboardOptions(<br>            keyboardType = KeyboardType.Password,<br>            imeAction = ImeAction.Next<br>        ),<br>        isPasswordField = true<br>    ) {<br>        inputViewModel.passwordField = inputViewModel.passwordField.copy(<br>            value = it,<br>            hasInteracted = true<br>        )<br>    }<br>}</pre>\n<p><strong>Explanation</strong>: A new input field is added for the password, which uses the custom password validation logic.</p>\n<blockquote>4. Button Validation Logic</blockquote>\n<p>Add the validation for the password field when the submit button is\u00a0clicked:</p>\n<pre>item {<br>    Button(<br>        onClick = {<br>            // Name validation<br>            if (inputViewModel.nameErrorStatus.isError) {<br>                inputViewModel.nameField = inputViewModel.nameField.copy(hasInteracted = true)<br>                inputViewModel.nameErrorStatus.errorMsg?.let {<br>                    context.showToast(it.asString(context))<br>                }<br>                return@Button<br>            }<br><br>            // Email validation<br>            if (inputViewModel.emailErrorStatus.isError) {<br>                inputViewModel.emailField = inputViewModel.emailField.copy(hasInteracted = true)<br>                inputViewModel.emailErrorStatus.errorMsg?.let {<br>                    context.showToast(it.asString(context))<br>                }<br>                return@Button<br>            }<br><br>            // Password validation<br>            if (inputViewModel.passwordErrorStatus.isError) {<br>                inputViewModel.passwordField = inputViewModel.passwordField.copy(hasInteracted = true)<br>                inputViewModel.passwordErrorStatus.errorMsg?.let {<br>                    context.showToast(it.asString(context))<br>                }<br>                return@Button<br>            }<br><br>            // Success message<br>            context.showToast(\"Success\")<br>        },<br>        modifier = Modifier.fillMaxWidth()<br>    ) {<br>        Text(text = stringResource(R.string.submit))<br>    }<br>}</pre>\n<p><strong>Explanation</strong>: The submit button now checks for validation errors in the name, email, and password fields before proceeding. If any errors are found, appropriate error messages are displayed.</p>\n<blockquote>Step 10: Example of Confirm Password Validation</blockquote>\n<p>In this step, we will add Confirm password validation in the utils file and update the <strong>InputViewModel </strong>and UI components accordingly.</p>\n<blockquote>1. Confirm Password Validation Function</blockquote>\n<p>Add the following Confirm password validation logic to the utils\u00a0file:</p>\n<pre>fun validateConPassword(password : String,conPassword : String) : ErrorStatus{<br>    return when {<br>        conPassword.trim().isEmpty() -&gt; {<br>            ErrorStatus(true, UiText.StringResource(R.string.required))<br>        }<br>        conPassword.trim().length &lt; 8  || conPassword.trim().length &gt; 10 -&gt; {<br>            ErrorStatus(true, UiText.StringResource(R.string.password_must_be_8_to_10_character))<br>        }<br>        password.trim() != conPassword.trim() -&gt; {<br>            ErrorStatus(true, UiText.StringResource(R.string.password_don_t_match))<br>        }<br>        else -&gt; {<br>            ErrorStatus(false)<br>        }<br>    }<br>}</pre>\n<p><strong>Explanation</strong>: This function checks if the confirm password field is empty, verifies if the length is between 8 and 10 characters, and ensures the password and confirm password match, returning an appropriate <strong>ErrorStatus</strong>.</p>\n<blockquote>2. Update the <strong><em>InputViewModel</em></strong>\n</blockquote>\n<p>Extend your <strong>InputViewModel </strong>to handle the validation for the confirm password\u00a0field:</p>\n<pre>class InputViewModel : ViewModel() {<br>    // Name field<br>    var nameField by mutableStateOf(FieldInput())<br>    val nameErrorStatus by derivedStateOf {<br>        validateName(nameField.value)<br>    }<br><br>    // Email field<br>    var emailField by mutableStateOf(FieldInput())<br>    val emailErrorStatus by derivedStateOf {<br>        validateEmail(emailField.value)<br>    }<br><br>    // Password field<br>    var passwordField by mutableStateOf(FieldInput())<br>    val passwordErrorStatus by derivedStateOf {<br>        validatePassword(passwordField.value)<br>    }<br><br>    // Confirm Password field<br>    var conPasswordField by mutableStateOf(FieldInput())<br>    val conPasswordErrorStatus by derivedStateOf {<br>        validateConPassword(passwordField.value, conPasswordField.value)<br>    }<br>}</pre>\n<p><strong>Explanation</strong>: The <strong>conPasswordField </strong>is added to the ViewModel along with <strong>conPasswordErrorStatus</strong>, which uses the <strong>validateConPassword </strong>function to derive its\u00a0value.</p>\n<blockquote>3. Add Confirm Password Input to the\u00a0UI</blockquote>\n<p>Update the UI to include a confirm password input field and validation:</p>\n<pre>// Name UI<br>item {<br>    OutlineFieldWithState(<br>        modifier = Modifier.fillMaxWidth(),<br>        label = stringResource(R.string.enter_the_name),<br>        fieldInput = inputViewModel.nameField,<br>        errorStatus = inputViewModel.nameErrorStatus,<br>        keyboardOptions = KeyboardOptions(<br>            keyboardType = KeyboardType.Text,<br>            capitalization = KeyboardCapitalization.Words,<br>            imeAction = ImeAction.Next<br>        ),<br>    ) {<br>        inputViewModel.nameField = inputViewModel.nameField.copy(<br>            value = it,<br>            hasInteracted = true<br>        )<br>    }<br>}<br><br>// Email UI<br>item {<br>    OutlineFieldWithState(<br>        modifier = Modifier.fillMaxWidth(),<br>        label = stringResource(R.string.enter_the_email),<br>        fieldInput = inputViewModel.emailField,<br>        errorStatus = inputViewModel.emailErrorStatus,<br>        leadingIconResource = IconResource.fromImageVector(Icons.Filled.Email),<br>        keyboardOptions = KeyboardOptions(<br>            keyboardType = KeyboardType.Email,<br>            imeAction = ImeAction.Next<br>        ),<br>    ) {<br>        inputViewModel.emailField = inputViewModel.emailField.copy(<br>            value = it,<br>            hasInteracted = true<br>        )<br>    }<br>}<br><br>// Password UI<br>item {<br>    OutlineFieldWithState(<br>        modifier = Modifier.fillMaxWidth(),<br>        label = stringResource(R.string.enter_the_password),<br>        fieldInput = inputViewModel.passwordField,<br>        errorStatus = inputViewModel.passwordErrorStatus,<br>        leadingIconResource = IconResource.fromImageVector(Icons.Filled.Lock),<br>        keyboardOptions = KeyboardOptions(<br>            keyboardType = KeyboardType.Password,<br>            imeAction = ImeAction.Next<br>        ),<br>        isPasswordField = true<br>    ) {<br>        inputViewModel.passwordField = inputViewModel.passwordField.copy(<br>            value = it,<br>            hasInteracted = true<br>        )<br>    }<br>}<br><br>// Confirm Password UI<br>item {<br>    OutlineFieldWithState(<br>        modifier = Modifier.fillMaxWidth(),<br>        label = stringResource(R.string.enter_the_confirm_password),<br>        fieldInput = inputViewModel.conPasswordField,<br>        errorStatus = inputViewModel.conPasswordErrorStatus,<br>        leadingIconResource = IconResource.fromImageVector(Icons.Filled.Lock),<br>        keyboardOptions = KeyboardOptions(<br>            keyboardType = KeyboardType.Password,<br>            imeAction = ImeAction.Done<br>        ),<br>        isPasswordField = true<br>    ) {<br>        inputViewModel.conPasswordField = inputViewModel.conPasswordField.copy(<br>            value = it,<br>            hasInteracted = true<br>        )<br>    }<br>}</pre>\n<p><strong>Explanation</strong>: A new input field is added for the confirm password, which uses the custom confirm password validation logic.</p>\n<blockquote>4. Button Validation Logic</blockquote>\n<p>Add the validation for the confirm password field when the submit button is\u00a0clicked:</p>\n<pre>item {<br>    Button(<br>        onClick = {<br>            // Name validation<br>            if (inputViewModel.nameErrorStatus.isError) {<br>                inputViewModel.nameField = inputViewModel.nameField.copy(hasInteracted = true)<br>                inputViewModel.nameErrorStatus.errorMsg?.let {<br>                    context.showToast(it.asString(context))<br>                }<br>                return@Button<br>            }<br><br>            // Email validation<br>            if (inputViewModel.emailErrorStatus.isError) {<br>                inputViewModel.emailField = inputViewModel.emailField.copy(hasInteracted = true)<br>                inputViewModel.emailErrorStatus.errorMsg?.let {<br>                    context.showToast(it.asString(context))<br>                }<br>                return@Button<br>            }<br><br>            // Password validation<br>            if (inputViewModel.passwordErrorStatus.isError) {<br>                inputViewModel.passwordField = inputViewModel.passwordField.copy(hasInteracted = true)<br>                inputViewModel.passwordErrorStatus.errorMsg?.let {<br>                    context.showToast(it.asString(context))<br>                }<br>                return@Button<br>            }<br><br>            // Confirm Password validation<br>            if (inputViewModel.conPasswordErrorStatus.isError) {<br>                inputViewModel.conPasswordField = inputViewModel.conPasswordField.copy(hasInteracted = true)<br>                inputViewModel.conPasswordErrorStatus.errorMsg?.let {<br>                    context.showToast(it.asString(context))<br>                }<br>                return@Button<br>            }<br><br>            // Success message<br>            context.showToast(\"Success\")<br>        },<br>        modifier = Modifier.fillMaxWidth()<br>    ) {<br>        Text(text = stringResource(R.string.submit))<br>    }<br>}</pre>\n<p><strong>Explanation</strong>: The submit button now validates all fields, including the confirm password, and displays relevant error messages if validation fails. If all validations pass, a success message is\u00a0shown.</p>\n<p>Here\u2019s your complete <strong>InputScreen </strong>implementation along with the <strong>MainActivity </strong>class. I've ensured that all the fields, including the confirm password field and the validation logic for each input, are included:</p>\n<pre>class MainActivity : ComponentActivity() {<br>    override fun onCreate(savedInstanceState: Bundle?) {<br>        super.onCreate(savedInstanceState)<br>        enableEdgeToEdge()<br>        setContent {<br>            InputValidationJCTheme {<br>                InputScreen()<br>            }<br>        }<br>    }<br>}<br><br>@Composable<br>fun InputScreen() {<br>    val context = LocalContext.current<br>    val inputViewModel: InputViewModel = viewModel()<br><br>    Scaffold(modifier = Modifier.fillMaxSize()) { innerPadding -&gt;<br>        LazyColumn(<br>            modifier = Modifier<br>                .fillMaxSize()<br>                .padding(innerPadding),<br>            contentPadding = PaddingValues(horizontal = 10.dp),<br>            horizontalAlignment = Alignment.CenterHorizontally,<br>            verticalArrangement = Arrangement.spacedBy(10.dp, Alignment.CenterVertically)<br>        ) {<br>            item {<br>                OutlineFieldWithState(<br>                    modifier = Modifier.fillMaxWidth(),<br>                    label = stringResource(R.string.enter_the_name),<br>                    fieldInput = inputViewModel.nameField,<br>                    errorStatus = inputViewModel.nameErrorStatus,<br>                    keyboardOptions = KeyboardOptions(<br>                        keyboardType = KeyboardType.Text,<br>                        capitalization = KeyboardCapitalization.Words,<br>                        imeAction = ImeAction.Next<br>                    ),<br>                ) {<br>                    inputViewModel.nameField = inputViewModel.nameField.copy(<br>                        value = it,<br>                        hasInteracted = true<br>                    )<br>                }<br>            }<br>            item {<br>                OutlineFieldWithState(<br>                    modifier = Modifier.fillMaxWidth(),<br>                    label = stringResource(R.string.enter_the_email),<br>                    fieldInput = inputViewModel.emailField,<br>                    errorStatus = inputViewModel.emailErrorStatus,<br>                    leadingIconResource = IconResource.fromImageVector(Icons.Filled.Email),<br>                    keyboardOptions = KeyboardOptions(<br>                        keyboardType = KeyboardType.Email,<br>                        imeAction = ImeAction.Next<br>                    ),<br>                ) {<br>                    inputViewModel.emailField = inputViewModel.emailField.copy(<br>                        value = it,<br>                        hasInteracted = true<br>                    )<br>                }<br>            }<br>            item {<br>                OutlineFieldWithState(<br>                    modifier = Modifier.fillMaxWidth(),<br>                    label = stringResource(R.string.enter_the_password),<br>                    fieldInput = inputViewModel.passwordField,<br>                    errorStatus = inputViewModel.passwordErrorStatus,<br>                    leadingIconResource = IconResource.fromImageVector(Icons.Filled.Lock),<br>                    keyboardOptions = KeyboardOptions(<br>                        keyboardType = KeyboardType.Password,<br>                        imeAction = ImeAction.Next<br>                    ),<br>                    isPasswordField = true<br>                ) {<br>                    inputViewModel.passwordField = inputViewModel.passwordField.copy(<br>                        value = it,<br>                        hasInteracted = true<br>                    )<br>                }<br>            }<br>            item {<br>                OutlineFieldWithState(<br>                    modifier = Modifier.fillMaxWidth(),<br>                    label = stringResource(R.string.enter_the_confirm_password),<br>                    fieldInput = inputViewModel.conPasswordField,<br>                    errorStatus = inputViewModel.conPasswordErrorStatus,<br>                    leadingIconResource = IconResource.fromImageVector(Icons.Filled.Lock),<br>                    keyboardOptions = KeyboardOptions(<br>                        keyboardType = KeyboardType.Password,<br>                        imeAction = ImeAction.Done<br>                    ),<br>                    isPasswordField = true<br>                ) {<br>                    inputViewModel.conPasswordField = inputViewModel.conPasswordField.copy(<br>                        value = it,<br>                        hasInteracted = true<br>                    )<br>                }<br>            }<br>            item {<br>                Button(<br>                    onClick = {<br>                        if (inputViewModel.nameErrorStatus.isError) {<br>                            inputViewModel.nameField = inputViewModel.nameField.copy(hasInteracted = true)<br>                            inputViewModel.nameErrorStatus.errorMsg?.let {<br>                                context.showToast(it.asString(context))<br>                            }<br>                            return@Button<br>                        }<br>                        if (inputViewModel.emailErrorStatus.isError) {<br>                            inputViewModel.emailField = inputViewModel.emailField.copy(hasInteracted = true)<br>                            inputViewModel.emailErrorStatus.errorMsg?.let {<br>                                context.showToast(it.asString(context))<br>                            }<br>                            return@Button<br>                        }<br>                        if (inputViewModel.passwordErrorStatus.isError) {<br>                            inputViewModel.passwordField = inputViewModel.passwordField.copy(hasInteracted = true)<br>                            inputViewModel.passwordErrorStatus.errorMsg?.let {<br>                                context.showToast(it.asString(context))<br>                            }<br>                            return@Button<br>                        }<br>                        if (inputViewModel.conPasswordErrorStatus.isError) {<br>                            inputViewModel.conPasswordField = inputViewModel.conPasswordField.copy(hasInteracted = true)<br>                            inputViewModel.conPasswordErrorStatus.errorMsg?.let {<br>                                context.showToast(it.asString(context))<br>                            }<br>                            return@Button<br>                        }<br><br>                        context.showToast(\"Success\")<br>                    },<br>                    modifier = Modifier.fillMaxWidth()<br>                ) {<br>                    Text(text = stringResource(R.string.submit))<br>                }<br>            }<br>        }<br>    }<br>}</pre>\n<h3>Key Points</h3>\n<ul>\n<li>The <strong>InputScreen </strong>function displays all the input fields, including <strong>name, email, password, and confirm password</strong>.</li>\n<li>Each input field utilizes the <strong>OutlineFieldWithState </strong>composable, which is presumably a custom composable for handling input fields with state management.</li>\n<li>The submit button validates each field before proceeding, showing appropriate error messages using a\u00a0toast.</li>\n<li>Ensure that the utility functions (<strong>validateName</strong>, <strong>validateEmail</strong>, <strong>validatePassword</strong>, and <strong>validateConPassword</strong>) and the <strong>InputViewModel </strong>are defined correctly to provide the necessary validation logic.</li>\n</ul>\n<h3>Conclusion</h3>\n<p>You\u2019ve successfully integrated <strong>form validation</strong> with <strong>Jetpack Compose</strong> in <strong>Android Studio</strong>. This implementation enhances your app\u2019s reliability by ensuring that user inputs are correctly validated, providing a smoother user experience. Now, you can run the app to ensure everything works smoothly and see the benefits of your validation logic in\u00a0action.</p>\n<p><strong>Happy coding!</strong></p>\n<p>Example GitHub\u00a0Repo:</p>\n<p><a href=\"https://github.com/Coding-Meet/Input-Validation-JC\">GitHub - Coding-Meet/Input-Validation-JC</a></p>\n<a href=\"https://medium.com/media/03ea2be5ab777b90e0a030ce0c9330cb/href\">https://medium.com/media/03ea2be5ab777b90e0a030ce0c9330cb/href</a><p>If you\u2019re interested in learning more about <strong>Kotlin Multiplatform</strong> and <strong>Compose Multiplatform</strong>, check out my playlist on YouTube Channel:<br><a href=\"https://youtube.com/playlist?list=PLlSuJy9SfzvEiYH59pDDNvFJjHoYLV0MM&amp;si=DhvNC5qiYh8rXzet\"><strong>Mastering Kotlin Multiplatform with Jetpack Compose: Complete Guide in\u00a0Hindi</strong></a></p>\n<p>Thank you for reading! \ud83d\ude4c\ud83d\ude4f\u270c I hope you found this guide\u00a0useful.</p>\n<p>Don\u2019t forget to clap \ud83d\udc4f to support me and follow for more insightful articles about Android Development, Kotlin, and KMP. If you need any help related to Android, Kotlin, and KMP, I\u2019m always happy to\u00a0assist.</p>\n<h3>Explore More\u00a0Projects</h3>\n<p>If you\u2019re interested in seeing full applications built with Kotlin Multiplatform and Jetpack Compose, check out these open-source projects:</p>\n<ul>\n<li>\n<strong>News Kotlin Multiplatform App</strong> (Supports Android, iOS, Windows, macOS, Linux):<br>News KMP App is a Kotlin Compose Multiplatform (KMP) project that aims to provide a consistent news reading experience across multiple platforms, including Android, iOS, Windows, macOS, and Linux. This project leverages Kotlin\u2019s multiplatform capabilities to share code and logic while using Compose for UI, ensuring a seamless and native experience on each platform.<br>GitHub Repository: <a href=\"https://github.com/Coding-Meet/News-KMP-App\">News-KMP-App</a>\n</li>\n<li>\n<strong>Gemini AI Kotlin Multiplatform App</strong> (Supports Android, iOS, Windows, macOS, Linux, and Web):<br>Gemini AI KMP App is a Kotlin Compose Multiplatform project designed by Gemini AI where you can retrieve information from text and images in a conversational format. Additionally, it allows storing chats group-wise using SQLDelight and KStore, and facilitates changing the Gemini API key.<br>GitHub Repository: <a href=\"https://github.com/Coding-Meet/Gemini-AI-KMP-App\">Gemini-AI-KMP-App</a>\n</li>\n</ul>\n<h3>Follow me\u00a0on</h3>\n<p><a href=\"https://medium.com/@meet26\">Medium</a>\u00a0, <a href=\"https://youtube.com/@codingmeet26?si=0unoWz53pxanSpv0\">YouTube\u00a0</a>, <a href=\"https://github.com/Coding-Meet\">GitHub</a>\u00a0, <a href=\"https://www.instagram.com/codingmeet26/\">Instagram</a>\u00a0, <a href=\"https://www.linkedin.com/in/coding-meet\">LinkedIn</a>\u00a0, <a href=\"https://www.buymeacoffee.com/CodingMeet\">Buy Me a Coffee</a>\u00a0, <a href=\"https://twitter.com/CodingMeet\">Twitter</a>\u00a0, <a href=\"https://telegram.me/Meetb26\">DM Me For Freelancing Project</a></p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=01e0464ae884\" width=\"1\" height=\"1\" alt=\"\"><hr>\n<p><a href=\"https://proandroiddev.com/full-guide-how-to-form-validation-with-jetpack-compose-01e0464ae884\">Full Guide: How to Form Validation With Jetpack Compose</a> was originally published in <a href=\"https://proandroiddev.com/\">ProAndroidDev</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>\n","enclosure":{},"categories":["form-validation","android","kotlin","jetpack-compose","android-studio"]},{"title":"How to Integrate Bottom Navigation Bar for compact screens and a Navigation Rail for larger screens\u2026","pubDate":"2024-09-20 04:54:34","link":"https://proandroiddev.com/how-to-integrate-bottom-navigation-bar-for-compact-screens-and-a-navigation-rail-for-larger-screens-c7dc3baab0e7?source=rss-b69c0e11154c------2","guid":"https://medium.com/p/c7dc3baab0e7","author":"Meet","thumbnail":"","description":"\n<h3>How to Integrate <strong>Bottom Navigation Bar</strong> for compact screens and a <strong>Navigation Rail</strong> for larger screens in a Compose Multiplatform</h3>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*riGHyX0ggxbceM7Uo-y9rA.png\"></figure><p>In this article, I\u2019ll guide you through integrating a <strong>Bottom Navigation Bar</strong> for compact screens and a <strong>Navigation Rail</strong> for larger screens in a Compose Multiplatform app. By the end, you\u2019ll have a fully functional app that adapts to various screen sizes, and can be deployed on Android, iOS, macOS, Linux, and\u00a0Windows.</p>\n<blockquote>Step 1: Add Dependencies to <strong>libs.versions.toml</strong>\n</blockquote>\n<p>First, add the necessary dependencies for navigation and window size classes in your <strong>libs.versions.toml</strong> file. This file defines the versions and library modules you'll use in your\u00a0project:</p>\n<pre>[versions]<br># Define the versions of the dependencies<br>navigationCompose = \"2.8.0-alpha02\"<br>size = \"0.5.0\"<br><br>[libraries]<br>navigation-compose = { module = \"org.jetbrains.androidx.navigation:navigation-compose\", version.ref = \"navigationCompose\" }<br>screen-size = { module = \"dev.chrisbanes.material3:material3-window-size-class-multiplatform\", version.ref = \"size\" }</pre>\n<p>Next, include these dependencies in the <strong>build.gradle.kts</strong> file of your Compose Multiplatform project to make them available across platforms:</p>\n<pre>// build.gradle.kts (Module :composeApp)<br>kotlin {<br>    sourceSets {<br>        val commonMain by getting {<br>            dependencies {<br>                // Material 3<br>                implementation(compose.material3)<br><br>                // Navigation<br>                implementation(libs.navigation.compose)<br><br>                // window-size<br>                implementation(libs.screen.size)<br>            }<br>        }<br>    }<br>}</pre>\n<blockquote>Step 2: Create a <strong>NavigationItem </strong>Data\u00a0Class</blockquote>\n<p>To manage the items for both the bottom navigation and the navigation rail, we need a data class that defines the properties for each navigation item. Here\u2019s how you can create a <strong>NavigationItem </strong>data class that works across different platforms in\u00a0Compose:</p>\n<pre>import androidx.compose.ui.graphics.vector.ImageVector<br>import org.jetbrains.compose.resources.DrawableResource<br>import org.jetbrains.compose.resources.StringResource<br><br>data class NavigationItem(<br>    val unSelectedIcon: ImageVector /* or  DrawableResource*/,<br>    val selectedIcon: ImageVector /* or  DrawableResource*/,<br>    val title: String /* or  StringResource  */,<br>    val route: String<br>)</pre>\n<p>In this step,\u00a0we:</p>\n<ul><li>create a <strong>NavigationItem </strong>data\u00a0class.</li></ul>\n<p>This data class allows you to define the icons, titles, and routes for each item in both the bottom navigation bar and navigation rail. You can use <strong>ImageVector </strong>or <strong>DrawableResource </strong>for the icons, and <strong>String </strong>or <strong>StringResource </strong>for the titles, making it flexible for different resource types in Compose Multiplatform.</p>\n<blockquote>Step 3: Define Navigation Routes and\u00a0Items</blockquote>\n<p>Next, you\u2019ll want to define the navigation routes for your app and list the navigation items. Here\u2019s how to set up a simple route system using <strong>sealed class </strong>and a list of <strong>NavigationItem </strong>objects:</p>\n<pre>import androidx.compose.material.icons.Icons<br>import androidx.compose.material.icons.filled.*<br>import androidx.compose.material.icons.outlined.*<br><br>object Graph {<br>    const val NAVIGATION_BAR_SCREEN_GRAPH = \"navigationBarScreenGraph\"<br>}<br><br>sealed class Routes(var route: String) {<br>    data object Home : Routes(\"home\")<br>    data object Setting : Routes(\"setting\")<br>    data object HomeDetail : Routes(\"homeDetail\")<br>    data object SettingDetail : Routes(\"settingDetail\")<br>}<br><br>val navigationItemsLists = listOf(<br>    NavigationItem(<br>        unSelectedIcon = Icons.Outlined.Home,<br>        selectedIcon = Icons.Filled.Home,<br>        title = \"Home\",<br>        route = Routes.Home.route,<br>    ),<br>    NavigationItem(<br>        unSelectedIcon = Icons.Outlined.Search,<br>        selectedIcon = Icons.Filled.Search,<br>        title = \"Setting\",<br>        route = Routes.Setting.route,<br>    ),<br>)</pre>\n<p>In this step,\u00a0we:</p>\n<ul>\n<li>Defined the main routes in the app using a sealed class\u00a0<strong>Routes</strong>.</li>\n<li>Created a list of <strong>NavigationItem </strong>objects, specifying the icons, titles, and routes for each item. These items will be used in both the bottom navigation bar and the navigation rail to handle navigation based on screen\u00a0size.</li>\n</ul>\n<blockquote>Step 4: Implement the Bottom Navigation Bar and Navigation Rail</blockquote>\n<p>To handle navigation across different screen sizes, we\u2019ll implement both a <strong>Bottom Navigation Bar</strong> (for smaller screens) and a <strong>Navigation Rail</strong> (for larger screens). These components will dynamically display navigation items based on the current\u00a0route.</p>\n<p>Here\u2019s how you can set up the <strong>BottomNavigationBar </strong>and <strong>NavigationSideBar </strong>composables:</p>\n<pre>import androidx.compose.foundation.layout.fillMaxHeight<br>import androidx.compose.foundation.layout.fillMaxWidth<br>import androidx.compose.foundation.layout.padding<br>import androidx.compose.material3.*<br>import androidx.compose.runtime.Composable<br>import androidx.compose.ui.Modifier<br>import androidx.compose.ui.text.style.TextOverflow<br>import androidx.compose.ui.unit.dp<br><br>@Composable<br>fun BottomNavigationBar(<br>    items: List&lt;NavigationItem&gt;,<br>    currentRoute: String?,<br>    onItemClick: (NavigationItem) -&gt; Unit<br>) {<br>    NavigationBar(<br>        modifier = Modifier.fillMaxWidth(),<br>    ) {<br>        items.forEach { navigationItem -&gt;<br>            NavigationBarItem(<br>                selected = currentRoute == navigationItem.route,<br>                onClick = { onItemClick(navigationItem) },<br>                icon = {<br>                    Icon(<br>                        imageVector = if (navigationItem.route == currentRoute) navigationItem.selectedIcon else navigationItem.unSelectedIcon,<br>                        contentDescription = navigationItem.title,<br>                    )<br>                },<br>                label = {<br>                    Text(<br>                        text = navigationItem.title,<br>                        style = if (navigationItem.route == currentRoute) MaterialTheme.typography.labelLarge<br>                        else MaterialTheme.typography.labelMedium,<br>                        maxLines = 1,<br>                        overflow = TextOverflow.Ellipsis<br>                    )<br>                },<br>            )<br>        }<br>    }<br>}<br><br>@Composable<br>fun NavigationSideBar(<br>    items: List&lt;NavigationItem&gt;,<br>    currentRoute: String?,<br>    onItemClick: (NavigationItem) -&gt; Unit<br>) {<br>    NavigationRail(<br>        modifier = Modifier.fillMaxHeight(),<br>        containerColor = MaterialTheme.colorScheme.surface,<br>    ) {<br>        items.forEach { navigationItem -&gt;<br>            NavigationRailItem(<br>                selected = navigationItem.route == currentRoute,<br>                onClick = { onItemClick(navigationItem) },<br>                icon = {<br>                    Icon(<br>                        imageVector = if (navigationItem.route == currentRoute) navigationItem.selectedIcon else navigationItem.unSelectedIcon,<br>                        contentDescription = navigationItem.title,<br>                    )<br>                },<br>                modifier = Modifier.padding(vertical = 12.dp),<br>                label = {<br>                    Text(<br>                        text = navigationItem.title,<br>                        style = if (navigationItem.route == currentRoute) MaterialTheme.typography.labelLarge<br>                        else MaterialTheme.typography.labelMedium,<br>                        maxLines = 1,<br>                        overflow = TextOverflow.Ellipsis<br>                    )<br>                },<br>            )<br>        }<br>    }<br>}</pre>\n<p>In this step,\u00a0we:</p>\n<ul>\n<li>Implemented the <strong>BottomNavigationBar </strong>composable for small screens. It uses a <strong>NavigationBar </strong>to display the items and highlights the selected one based on the <strong>currentRoute</strong>.</li>\n<li>Created the <strong>NavigationSideBar </strong>composable for large screens. It uses a <strong>NavigationRail </strong>and similarly highlights the selected\u00a0item.</li>\n</ul>\n<p>Both components are designed to switch between the unselected and selected icons, update the text style based on the route, and handle clicks with the <strong>onItemClick</strong> callback.</p>\n<blockquote>Step 5: Implement Home and Home Detail\u00a0Screens</blockquote>\n<p>To create the screens that will be displayed when navigating between the home and its detail, we define <strong>HomeScreen </strong>and <strong>HomeDetailScreen</strong>. These screens handle user input and navigation between each\u00a0other.</p>\n<pre>import androidx.compose.foundation.layout.*<br>import androidx.compose.material.icons.Icons<br>import androidx.compose.material.icons.automirrored.filled.ArrowBack<br>import androidx.compose.material3.*<br>import androidx.compose.runtime.*<br>import androidx.compose.ui.Alignment<br>import androidx.compose.ui.Modifier<br>import androidx.compose.ui.text.font.FontWeight<br>import androidx.compose.ui.unit.dp<br>import androidx.compose.ui.unit.sp<br>import androidx.navigation.NavController<br>import com.meet.bottom_navigation_bar_navigation_rail.navigation.Routes<br><br>@OptIn(ExperimentalMaterial3Api::class)<br>@Composable<br>fun HomeScreen(<br>    rootNavController: NavController, paddingValues: PaddingValues<br>) {<br>    var name by remember { mutableStateOf(\"\") }<br><br>    Column(<br>        modifier = Modifier<br>            .fillMaxSize()<br>            .padding(paddingValues),<br>        verticalArrangement = Arrangement.SpaceBetween,<br>        horizontalAlignment = Alignment.CenterHorizontally<br>    ) {<br>        TopAppBar(<br>            title = {<br>                Text(<br>                    text = \"Home\",<br>                    style = MaterialTheme.typography.headlineLarge,<br>                    fontWeight = FontWeight.Bold,<br>                    color = MaterialTheme.colorScheme.onBackground<br>                )<br>            }<br>        )<br><br>        Spacer(modifier = Modifier.height(20.dp))<br><br>        TextField(<br>            value = name,<br>            onValueChange = { name = it },<br>            label = { Text(text = \"Enter the name\") }<br>        )<br><br>        Button(onClick = {<br>            rootNavController.currentBackStackEntry?.savedStateHandle?.apply {<br>                set(\"name\", name)<br>            }<br>            rootNavController.navigate(Routes.HomeDetail.route)<br>        }) {<br>            Text(<br>                text = \"Move to Home Detail Screen\",<br>                fontSize = 20.sp<br>            )<br>        }<br><br>        Spacer(modifier = Modifier.height(20.dp))<br>    }<br>}<br><br>@OptIn(ExperimentalMaterial3Api::class)<br>@Composable<br>fun HomeDetailScreen(<br>    rootNavController: NavController,<br>    name: String<br>) {<br>    Column(<br>        modifier = Modifier.fillMaxSize(),<br>        verticalArrangement = Arrangement.SpaceBetween,<br>        horizontalAlignment = Alignment.CenterHorizontally<br>    ) {<br>        TopAppBar(<br>            title = {<br>                Text(<br>                    text = \"Home Detail\",<br>                    style = MaterialTheme.typography.headlineLarge,<br>                    fontWeight = FontWeight.Bold,<br>                    color = MaterialTheme.colorScheme.onBackground<br>                )<br>            },<br>            navigationIcon = {<br>                IconButton(onClick = { rootNavController.navigateUp() }) {<br>                    Icon(<br>                        imageVector = Icons.AutoMirrored.Filled.ArrowBack,<br>                        contentDescription = null,<br>                    )<br>                }<br>            }<br>        )<br><br>        Text(<br>            text = \"Name = ${'$'}name\",<br>            fontSize = 20.sp<br>        )<br><br>        Spacer(modifier = Modifier.height(20.dp))<br>    }<br>}</pre>\n<p>In this\u00a0step:</p>\n<ul>\n<li>\n<strong>HomeScreen </strong>allows users to input a name and navigate to <strong>HomeDetailScreen</strong>, passing the entered name using <strong>savedStateHandle</strong>.</li>\n<li>\n<strong>HomeDetailScreen </strong>displays the passed name and provides a back button to return to <strong>HomeScreen</strong>.</li>\n</ul>\n<blockquote>Step 6: Implement Setting and Setting Detail\u00a0Screens</blockquote>\n<p>Now, let\u2019s create the <strong>SettingScreen </strong>and <strong>SettingDetailScreen </strong>to manage settings in your app and allow navigation between these\u00a0screens.</p>\n<pre>import androidx.compose.foundation.layout.*<br>import androidx.compose.material.icons.Icons<br>import androidx.compose.material.icons.automirrored.filled.ArrowBack<br>import androidx.compose.material3.*<br>import androidx.compose.runtime.Composable<br>import androidx.compose.ui.Alignment<br>import androidx.compose.ui.Modifier<br>import androidx.compose.ui.text.font.FontWeight<br>import androidx.compose.ui.unit.dp<br>import androidx.compose.ui.unit.sp<br>import androidx.navigation.NavController<br>import com.meet.bottom_navigation_bar_navigation_rail.navigation.Routes<br><br>@OptIn(ExperimentalMaterial3Api::class)<br>@Composable<br>fun SettingScreen(<br>    rootNavController: NavController,<br>    paddingValues: PaddingValues<br>) {<br>    Column(<br>        modifier = Modifier<br>            .fillMaxSize()<br>            .padding(paddingValues),<br>        verticalArrangement = Arrangement.SpaceBetween,<br>        horizontalAlignment = Alignment.CenterHorizontally<br>    ) {<br>        TopAppBar(<br>            title = {<br>                Text(<br>                    text = \"Setting\",<br>                    style = MaterialTheme.typography.headlineLarge,<br>                    fontWeight = FontWeight.Bold,<br>                    color = MaterialTheme.colorScheme.onBackground<br>                )<br>            }<br>        )<br><br>        Spacer(modifier = Modifier.height(20.dp))<br><br>        Button(onClick = {<br>            rootNavController.navigate(Routes.SettingDetail.route)<br>        }) {<br>            Text(<br>                text = \"Move to Setting Detail Screen\",<br>                fontSize = 20.sp<br>            )<br>        }<br><br>        Spacer(modifier = Modifier.height(20.dp))<br>    }<br>}<br><br>@OptIn(ExperimentalMaterial3Api::class)<br>@Composable<br>fun SettingDetailScreen(<br>    rootNavController: NavController,<br>) {<br>    Column(<br>        modifier = Modifier.fillMaxSize(),<br>        verticalArrangement = Arrangement.SpaceBetween,<br>        horizontalAlignment = Alignment.CenterHorizontally<br>    ) {<br>        TopAppBar(<br>            title = {<br>                Text(<br>                    text = \"Setting Detail\",<br>                    style = MaterialTheme.typography.headlineLarge,<br>                    fontWeight = FontWeight.Bold,<br>                    color = MaterialTheme.colorScheme.onBackground<br>                )<br>            },<br>            navigationIcon = {<br>                IconButton(onClick = { rootNavController.navigateUp() }) {<br>                    Icon(<br>                        imageVector = Icons.AutoMirrored.Filled.ArrowBack,<br>                        contentDescription = null,<br>                    )<br>                }<br>            }<br>        )<br>    }<br>}</pre>\n<p>In this\u00a0step:</p>\n<ul>\n<li>\n<strong>SettingScreen </strong>presents a button to navigate to <strong>SettingDetailScreen</strong>.</li>\n<li>\n<strong>SettingDetailScreen </strong>provides a back button to return to the <strong>SettingScreen</strong>.</li>\n</ul>\n<blockquote>Step 7: Set Up the Navigation Graph</blockquote>\n<p>To handle screen navigation in your Compose Multiplatform app, set up the navigation graph. This will include both the main screens and detail screens. The <strong>RootNavGraph </strong>function will define the main structure for navigation, while the <strong>mainNavGraph </strong>function will handle the individual navigation routes.</p>\n<pre>import androidx.compose.foundation.layout.PaddingValues<br>import androidx.compose.runtime.Composable<br>import androidx.navigation.NavGraphBuilder<br>import androidx.navigation.NavHostController<br>import androidx.navigation.compose.NavHost<br>import androidx.navigation.compose.composable<br>import androidx.navigation.navigation<br>import com.meet.bottom_navigation_bar_navigation_rail.navigation.Graph<br>import com.meet.bottom_navigation_bar_navigation_rail.navigation.Routes<br>import com.meet.bottom_navigation_bar_navigation_rail.screens.HomeDetailScreen<br>import com.meet.bottom_navigation_bar_navigation_rail.screens.HomeScreen<br>import com.meet.bottom_navigation_bar_navigation_rail.screens.SettingDetailScreen<br>import com.meet.bottom_navigation_bar_navigation_rail.screens.SettingScreen<br><br>@Composable<br>fun RootNavGraph(<br>    rootNavController: NavHostController,<br>    innerPadding: PaddingValues<br>) {<br>    NavHost(<br>        navController = rootNavController,<br>        startDestination = Graph.NAVIGATION_BAR_SCREEN_GRAPH,<br>    ) {<br>        mainNavGraph(rootNavController = rootNavController, innerPadding = innerPadding)<br>        composable(<br>            route = Routes.HomeDetail.route,<br>        ) {<br>            rootNavController.previousBackStackEntry?.savedStateHandle?.get&lt;String&gt;(\"name\")?.let { name -&gt;<br>                HomeDetailScreen(rootNavController = rootNavController, name = name)<br>            }<br>        }<br>        composable(<br>            route = Routes.SettingDetail.route,<br>        ) {<br>            SettingDetailScreen(rootNavController = rootNavController)<br>        }<br>    }<br>}<br>fun NavGraphBuilder.mainNavGraph(<br>    rootNavController: NavHostController,<br>    innerPadding: PaddingValues<br>) {<br>    navigation(<br>        startDestination = Routes.Home.route,<br>        route = Graph.NAVIGATION_BAR_SCREEN_GRAPH<br>    ) {<br>        composable(route = Routes.Home.route) {<br>            HomeScreen(rootNavController = rootNavController, paddingValues = innerPadding)<br>        }<br>        composable(route = Routes.Setting.route) {<br>            SettingScreen(rootNavController = rootNavController, paddingValues = innerPadding)<br>        }<br>    }<br>}</pre>\n<p>In this\u00a0step:</p>\n<ul>\n<li>We define a <strong>RootNavGraph </strong>that starts the navigation graph and handles both main and detail\u00a0screens.</li>\n<li>\n<strong>mainNavGraph </strong>manages the navigation for the <strong>HomeScreen </strong>and <strong>SettingScreen</strong>.</li>\n<li>We use <strong>composable </strong>to declare each screen's route, and for the detail screens (<strong>HomeDetailScreen</strong>, <strong>SettingDetailScreen)</strong>, we retrieve parameters using <strong>savedStateHandle</strong> when navigating between\u00a0them.</li>\n</ul>\n<blockquote>Step 8: Building the Adaptive UI for Different Screen\u00a0Sizes</blockquote>\n<p>In this step, we\u2019ll implement the <strong>MainScreen </strong>composable, which handles displaying either the <strong>Bottom Navigation Bar</strong> or the <strong>Navigation Rail</strong> based on the screen\u00a0size.</p>\n<pre>import androidx.compose.animation.*<br>import androidx.compose.foundation.background<br>import androidx.compose.foundation.layout.Row<br>import androidx.compose.material3.MaterialTheme<br>import androidx.compose.material3.Scaffold<br>import androidx.compose.material3.windowsizeclass.ExperimentalMaterial3WindowSizeClassApi<br>import androidx.compose.material3.windowsizeclass.WindowWidthSizeClass<br>import androidx.compose.material3.windowsizeclass.calculateWindowSizeClass<br>import androidx.compose.runtime.*<br>import androidx.navigation.NavHostController<br>import androidx.navigation.compose.currentBackStackEntryAsState<br>import androidx.navigation.compose.rememberNavController<br>import com.meet.bottom_navigation_bar_navigation_rail.navigation.*<br><br>@OptIn(ExperimentalMaterial3WindowSizeClassApi::class)<br>@Composable<br>fun MainScreen() {<br>    val windowSizeClass = calculateWindowSizeClass()<br>    val isMediumExpandedWWSC by remember(windowSizeClass) {<br>        derivedStateOf {<br>            windowSizeClass.widthSizeClass != WindowWidthSizeClass.Compact<br>        }<br>    }<br>    val rootNavController = rememberNavController()<br>    val navBackStackEntry by rootNavController.currentBackStackEntryAsState()<br>    val currentRoute by remember(navBackStackEntry) {<br>        derivedStateOf {<br>            navBackStackEntry?.destination?.route<br>        }<br>    }<br>    val navigationItem by remember {<br>        derivedStateOf {<br>            navigationItemsLists.find { it.route == currentRoute }<br>        }<br>    }<br>    val isMainScreenVisible by remember(isMediumExpandedWWSC) {<br>        derivedStateOf {<br>            navigationItem != null<br>        }<br>    }<br>    val isBottomBarVisible by remember(isMediumExpandedWWSC) {<br>        derivedStateOf {<br>            if (!isMediumExpandedWWSC) {<br>                navigationItem != null<br>            } else {<br>                false<br>            }<br>        }<br>    }<br>    MainScaffold(<br>        rootNavController = rootNavController,<br>        currentRoute = currentRoute,<br>        isMediumExpandedWWSC = isMediumExpandedWWSC,<br>        isBottomBarVisible = isBottomBarVisible,<br>        isMainScreenVisible = isMainScreenVisible,<br>        onItemClick = { currentNavigationItem -&gt;<br>            rootNavController.navigate(currentNavigationItem.route) {<br>                popUpTo(rootNavController.graph.startDestinationRoute ?: \"\") {<br>                    saveState = true<br>                }<br>                launchSingleTop = true<br>                restoreState = true<br>            }<br>        }<br>    )<br>}<br><br>@Composable<br>fun MainScaffold(<br>    rootNavController: NavHostController,<br>    currentRoute: String?,<br>    isMediumExpandedWWSC: Boolean,<br>    isBottomBarVisible: Boolean,<br>    isMainScreenVisible: Boolean,<br>    onItemClick: (NavigationItem) -&gt; Unit,<br>) {<br>    Row {<br>        AnimatedVisibility(<br>            modifier = Modifier.background(MaterialTheme.colorScheme.surface),<br>            visible = isMediumExpandedWWSC &amp;&amp; isMainScreenVisible,<br>            enter = slideInHorizontally(<br>                // Slide in from the left<br>                initialOffsetX = { fullWidth -&gt; -fullWidth }<br>            ),<br>            exit = slideOutHorizontally(<br>                // Slide out to the right<br>                targetOffsetX = { fullWidth -&gt; -fullWidth }<br>            )<br>        ) {<br>            NavigationSideBar(<br>                items = navigationItemsLists,<br>                currentRoute = currentRoute,<br>                onItemClick = { currentNavigationItem -&gt;<br>                    onItemClick(currentNavigationItem)<br>                }<br>            )<br>        }<br>        Scaffold(<br>            bottomBar = {<br>                AnimatedVisibility(<br>                    visible = isBottomBarVisible,<br>                    enter = slideInVertically(<br>                        // Slide in from the bottom<br>                        initialOffsetY = { fullHeight -&gt; fullHeight }<br>                    ),<br>                    exit = slideOutVertically(<br>                        // Slide out to the bottom<br>                        targetOffsetY = { fullHeight -&gt; fullHeight }<br>                    )<br>                ) {<br>                    BottomNavigationBar(<br>                        items = navigationItemsLists,<br>                        currentRoute = currentRoute,<br>                        onItemClick = { currentNavigationItem -&gt;<br>                            onItemClick(currentNavigationItem)<br>                        }<br>                    )<br>                }<br>            }<br>        ) { innerPadding -&gt;<br>            RootNavGraph(<br>                rootNavController = rootNavController,<br>                innerPadding = innerPadding,<br>            )<br>        }<br>    }<br>}</pre>\n<p>Here, we use <strong>WindowSizeClass </strong>to dynamically adapt the UI based on the width of the device screen. If the width is compact, we show the <strong>Bottom Navigation Bar</strong>; if it\u2019s larger (like on tablets or desktops), we switch to a <strong>Navigation Rail</strong> for better usability.</p>\n<p>Here\u2019s a breakdown of how it\u00a0works:</p>\n<ul>\n<li>\n<strong>WindowSizeClass</strong>: Helps detect the screen size. We use it to differentiate between compact and expanded\u00a0layouts.</li>\n<li>\n<strong>AnimatedVisibility</strong>: This Jetpack Compose API is used to animate the transition between the Bottom Navigation Bar and the Navigation Rail. For example, when switching to a larger screen size, the Navigation Rail slides in from the left, giving a polished, responsive look.</li>\n<li>\n<strong>Scaffold</strong>: Acts as the container for the UI layout, managing the positioning of the Bottom Navigation Bar and the Navigation Rail, along with handling content\u00a0padding.</li>\n</ul>\n<p>By doing this, you create a flexible UI that works for both smaller devices like phones, where space is limited, and larger screens like tablets and desktops, where more space allows for a side navigation rail.</p>\n<blockquote>Step 9: Create the Main Composable Function</blockquote>\n<p>In this step, we\u2019ll define the <strong>App </strong>composable in the common module. This function will act as the entry point of the application, applying a <strong>MaterialTheme </strong>to the <strong>MainScreen</strong>.</p>\n<pre>import androidx.compose.material.MaterialTheme<br>import androidx.compose.runtime.Composable<br>import org.jetbrains.compose.ui.tooling.preview.Preview<br><br>@Composable<br>@Preview<br>fun App() {<br>    MaterialTheme {<br>        MainScreen()<br>    }<br>}</pre>\n<p>In this\u00a0step:</p>\n<ul>\n<li>We define the <strong>App </strong>composable, which wraps <strong>MainScreen </strong>in a <strong>MaterialTheme</strong>, ensuring a consistent look and feel across the\u00a0app.</li>\n<li>A <strong>@Preview </strong>annotation is used for quickly visualizing the <strong>App </strong>composable during development.</li>\n</ul>\n<blockquote>Step 10: Set Up the Desktop\u00a0Module</blockquote>\n<p>Now let\u2019s set up the <strong>main </strong>function in the desktop module to launch the app. This function defines the application window and the entry point of the desktop\u00a0app.</p>\n<pre>import androidx.compose.ui.window.Window<br>import androidx.compose.ui.window.application<br>import java.awt.Dimension<br><br>fun main() = application {<br>    Window(<br>        onCloseRequest = ::exitApplication,<br>        title = \"Bottom-Navigation-Bar-Navigation-Rail\",<br>    ) {<br>        window.minimumSize = Dimension(640, 480)<br>        App()<br>    }<br>}</pre>\n<p>In this\u00a0step:</p>\n<ul>\n<li>We use <strong>Window </strong>from <strong>androidx.compose.ui.window</strong> to create the desktop app's main\u00a0window.</li>\n<li>\n<strong>App()</strong> is called to display the UI within the\u00a0window.</li>\n<li>The minimum window size is set to <strong>640x480</strong> to ensure proper display on smaller\u00a0screens.</li>\n</ul>\n<h3>Conclusion</h3>\n<p>You\u2019ve successfully integrated <strong>Bottom Navigation Bar</strong> for compact screens and a <strong>Navigation Rail</strong> for larger screens in a <strong>Compose Multiplatform</strong>. Now, you can run the app on each platform\u200a\u2014\u200a<strong>Android, iOS, macOS, Linux, and Windows</strong>\u200a\u2014\u200ato ensure everything works smoothly.</p>\n<p>Example Github\u00a0Repo:</p>\n<ul>\n<li><a href=\"https://github.com/Coding-Meet/Bottom-Navigation-Bar-Navigation-Rail-KMP\">GitHub - Coding-Meet/Bottom-Navigation-Bar-Navigation-Rail-KMP</a></li>\n<li><a href=\"https://github.com/Coding-Meet/News-KMP-App\">GitHub - Coding-Meet/News-KMP-App: News Kotlin Multiplatform project designed to target Android, iOS, Windows, macOS, Linux platforms.</a></li>\n</ul>\n<a href=\"https://medium.com/media/0978046c7e7b122964874b23b4aa1223/href\">https://medium.com/media/0978046c7e7b122964874b23b4aa1223/href</a><p>If you\u2019re interested in learning more about <strong>Kotlin Multiplatform</strong> and <strong>Compose Multiplatform</strong>, check out my playlist on YouTube Channel:<br><a href=\"https://youtube.com/playlist?list=PLlSuJy9SfzvEiYH59pDDNvFJjHoYLV0MM&amp;si=DhvNC5qiYh8rXzet\"><strong>Mastering Kotlin Multiplatform with Jetpack Compose: Complete Guide in\u00a0Hindi</strong></a></p>\n<p>Thank you for reading! \ud83d\ude4c\ud83d\ude4f\u270c I hope you found this guide\u00a0useful.</p>\n<p>Don\u2019t forget to clap \ud83d\udc4f to support me and follow for more insightful articles about Android Development, Kotlin, and KMP. If you need any help related to Android, Kotlin, and KMP, I\u2019m always happy to\u00a0assist.</p>\n<h3>Explore More\u00a0Projects</h3>\n<p>If you\u2019re interested in seeing full applications built with Kotlin Multiplatform and Jetpack Compose, check out these open-source projects:</p>\n<ul>\n<li>\n<strong>News Kotlin Multiplatform App</strong> (Supports Android, iOS, Windows, macOS, Linux):<br>News KMP App is a Kotlin Compose Multiplatform (KMP) project that aims to provide a consistent news reading experience across multiple platforms, including Android, iOS, Windows, macOS, and Linux. This project leverages Kotlin\u2019s multiplatform capabilities to share code and logic while using Compose for UI, ensuring a seamless and native experience on each platform.<br>GitHub Repository: <a href=\"https://github.com/Coding-Meet/News-KMP-App\">News-KMP-App</a>\n</li>\n<li>\n<strong>Gemini AI Kotlin Multiplatform App</strong> (Supports Android, iOS, Windows, macOS, Linux, and Web):<br>Gemini AI KMP App is a Kotlin Compose Multiplatform project designed by Gemini AI where you can retrieve information from text and images in a conversational format. Additionally, it allows storing chats group-wise using SQLDelight and KStore, and facilitates changing the Gemini API key.<br>GitHub Repository: <a href=\"https://github.com/Coding-Meet/Gemini-AI-KMP-App\">Gemini-AI-KMP-App</a>\n</li>\n</ul>\n<h3>Follow me\u00a0on</h3>\n<p><a href=\"https://medium.com/@meet26\">Medium</a>\u00a0, <a href=\"https://youtube.com/@codingmeet26?si=0unoWz53pxanSpv0\">YouTube\u00a0</a>, <a href=\"https://github.com/Coding-Meet?source=about_page-------------------------------------\">GitHub</a>\u00a0, <a href=\"https://www.instagram.com/codingmeet26/?source=about_page-------------------------------------\">Instagram</a>\u00a0, <a href=\"https://www.linkedin.com/in/coding-meet?source=about_page-------------------------------------\">LinkedIn</a>\u00a0, <a href=\"https://www.buymeacoffee.com/CodingMeet?source=about_page-------------------------------------\">Buy Me a Coffee</a>\u00a0,\u00a0<a href=\"https://twitter.com/CodingMeet?source=about_page-------------------------------------\">Twitter</a></p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=c7dc3baab0e7\" width=\"1\" height=\"1\" alt=\"\"><hr>\n<p><a href=\"https://proandroiddev.com/how-to-integrate-bottom-navigation-bar-for-compact-screens-and-a-navigation-rail-for-larger-screens-c7dc3baab0e7\">How to Integrate Bottom Navigation Bar for compact screens and a Navigation Rail for larger screens\u2026</a> was originally published in <a href=\"https://proandroiddev.com/\">ProAndroidDev</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>\n","content":"\n<h3>How to Integrate <strong>Bottom Navigation Bar</strong> for compact screens and a <strong>Navigation Rail</strong> for larger screens in a Compose Multiplatform</h3>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*riGHyX0ggxbceM7Uo-y9rA.png\"></figure><p>In this article, I\u2019ll guide you through integrating a <strong>Bottom Navigation Bar</strong> for compact screens and a <strong>Navigation Rail</strong> for larger screens in a Compose Multiplatform app. By the end, you\u2019ll have a fully functional app that adapts to various screen sizes, and can be deployed on Android, iOS, macOS, Linux, and\u00a0Windows.</p>\n<blockquote>Step 1: Add Dependencies to <strong>libs.versions.toml</strong>\n</blockquote>\n<p>First, add the necessary dependencies for navigation and window size classes in your <strong>libs.versions.toml</strong> file. This file defines the versions and library modules you'll use in your\u00a0project:</p>\n<pre>[versions]<br># Define the versions of the dependencies<br>navigationCompose = \"2.8.0-alpha02\"<br>size = \"0.5.0\"<br><br>[libraries]<br>navigation-compose = { module = \"org.jetbrains.androidx.navigation:navigation-compose\", version.ref = \"navigationCompose\" }<br>screen-size = { module = \"dev.chrisbanes.material3:material3-window-size-class-multiplatform\", version.ref = \"size\" }</pre>\n<p>Next, include these dependencies in the <strong>build.gradle.kts</strong> file of your Compose Multiplatform project to make them available across platforms:</p>\n<pre>// build.gradle.kts (Module :composeApp)<br>kotlin {<br>    sourceSets {<br>        val commonMain by getting {<br>            dependencies {<br>                // Material 3<br>                implementation(compose.material3)<br><br>                // Navigation<br>                implementation(libs.navigation.compose)<br><br>                // window-size<br>                implementation(libs.screen.size)<br>            }<br>        }<br>    }<br>}</pre>\n<blockquote>Step 2: Create a <strong>NavigationItem </strong>Data\u00a0Class</blockquote>\n<p>To manage the items for both the bottom navigation and the navigation rail, we need a data class that defines the properties for each navigation item. Here\u2019s how you can create a <strong>NavigationItem </strong>data class that works across different platforms in\u00a0Compose:</p>\n<pre>import androidx.compose.ui.graphics.vector.ImageVector<br>import org.jetbrains.compose.resources.DrawableResource<br>import org.jetbrains.compose.resources.StringResource<br><br>data class NavigationItem(<br>    val unSelectedIcon: ImageVector /* or  DrawableResource*/,<br>    val selectedIcon: ImageVector /* or  DrawableResource*/,<br>    val title: String /* or  StringResource  */,<br>    val route: String<br>)</pre>\n<p>In this step,\u00a0we:</p>\n<ul><li>create a <strong>NavigationItem </strong>data\u00a0class.</li></ul>\n<p>This data class allows you to define the icons, titles, and routes for each item in both the bottom navigation bar and navigation rail. You can use <strong>ImageVector </strong>or <strong>DrawableResource </strong>for the icons, and <strong>String </strong>or <strong>StringResource </strong>for the titles, making it flexible for different resource types in Compose Multiplatform.</p>\n<blockquote>Step 3: Define Navigation Routes and\u00a0Items</blockquote>\n<p>Next, you\u2019ll want to define the navigation routes for your app and list the navigation items. Here\u2019s how to set up a simple route system using <strong>sealed class </strong>and a list of <strong>NavigationItem </strong>objects:</p>\n<pre>import androidx.compose.material.icons.Icons<br>import androidx.compose.material.icons.filled.*<br>import androidx.compose.material.icons.outlined.*<br><br>object Graph {<br>    const val NAVIGATION_BAR_SCREEN_GRAPH = \"navigationBarScreenGraph\"<br>}<br><br>sealed class Routes(var route: String) {<br>    data object Home : Routes(\"home\")<br>    data object Setting : Routes(\"setting\")<br>    data object HomeDetail : Routes(\"homeDetail\")<br>    data object SettingDetail : Routes(\"settingDetail\")<br>}<br><br>val navigationItemsLists = listOf(<br>    NavigationItem(<br>        unSelectedIcon = Icons.Outlined.Home,<br>        selectedIcon = Icons.Filled.Home,<br>        title = \"Home\",<br>        route = Routes.Home.route,<br>    ),<br>    NavigationItem(<br>        unSelectedIcon = Icons.Outlined.Search,<br>        selectedIcon = Icons.Filled.Search,<br>        title = \"Setting\",<br>        route = Routes.Setting.route,<br>    ),<br>)</pre>\n<p>In this step,\u00a0we:</p>\n<ul>\n<li>Defined the main routes in the app using a sealed class\u00a0<strong>Routes</strong>.</li>\n<li>Created a list of <strong>NavigationItem </strong>objects, specifying the icons, titles, and routes for each item. These items will be used in both the bottom navigation bar and the navigation rail to handle navigation based on screen\u00a0size.</li>\n</ul>\n<blockquote>Step 4: Implement the Bottom Navigation Bar and Navigation Rail</blockquote>\n<p>To handle navigation across different screen sizes, we\u2019ll implement both a <strong>Bottom Navigation Bar</strong> (for smaller screens) and a <strong>Navigation Rail</strong> (for larger screens). These components will dynamically display navigation items based on the current\u00a0route.</p>\n<p>Here\u2019s how you can set up the <strong>BottomNavigationBar </strong>and <strong>NavigationSideBar </strong>composables:</p>\n<pre>import androidx.compose.foundation.layout.fillMaxHeight<br>import androidx.compose.foundation.layout.fillMaxWidth<br>import androidx.compose.foundation.layout.padding<br>import androidx.compose.material3.*<br>import androidx.compose.runtime.Composable<br>import androidx.compose.ui.Modifier<br>import androidx.compose.ui.text.style.TextOverflow<br>import androidx.compose.ui.unit.dp<br><br>@Composable<br>fun BottomNavigationBar(<br>    items: List&lt;NavigationItem&gt;,<br>    currentRoute: String?,<br>    onItemClick: (NavigationItem) -&gt; Unit<br>) {<br>    NavigationBar(<br>        modifier = Modifier.fillMaxWidth(),<br>    ) {<br>        items.forEach { navigationItem -&gt;<br>            NavigationBarItem(<br>                selected = currentRoute == navigationItem.route,<br>                onClick = { onItemClick(navigationItem) },<br>                icon = {<br>                    Icon(<br>                        imageVector = if (navigationItem.route == currentRoute) navigationItem.selectedIcon else navigationItem.unSelectedIcon,<br>                        contentDescription = navigationItem.title,<br>                    )<br>                },<br>                label = {<br>                    Text(<br>                        text = navigationItem.title,<br>                        style = if (navigationItem.route == currentRoute) MaterialTheme.typography.labelLarge<br>                        else MaterialTheme.typography.labelMedium,<br>                        maxLines = 1,<br>                        overflow = TextOverflow.Ellipsis<br>                    )<br>                },<br>            )<br>        }<br>    }<br>}<br><br>@Composable<br>fun NavigationSideBar(<br>    items: List&lt;NavigationItem&gt;,<br>    currentRoute: String?,<br>    onItemClick: (NavigationItem) -&gt; Unit<br>) {<br>    NavigationRail(<br>        modifier = Modifier.fillMaxHeight(),<br>        containerColor = MaterialTheme.colorScheme.surface,<br>    ) {<br>        items.forEach { navigationItem -&gt;<br>            NavigationRailItem(<br>                selected = navigationItem.route == currentRoute,<br>                onClick = { onItemClick(navigationItem) },<br>                icon = {<br>                    Icon(<br>                        imageVector = if (navigationItem.route == currentRoute) navigationItem.selectedIcon else navigationItem.unSelectedIcon,<br>                        contentDescription = navigationItem.title,<br>                    )<br>                },<br>                modifier = Modifier.padding(vertical = 12.dp),<br>                label = {<br>                    Text(<br>                        text = navigationItem.title,<br>                        style = if (navigationItem.route == currentRoute) MaterialTheme.typography.labelLarge<br>                        else MaterialTheme.typography.labelMedium,<br>                        maxLines = 1,<br>                        overflow = TextOverflow.Ellipsis<br>                    )<br>                },<br>            )<br>        }<br>    }<br>}</pre>\n<p>In this step,\u00a0we:</p>\n<ul>\n<li>Implemented the <strong>BottomNavigationBar </strong>composable for small screens. It uses a <strong>NavigationBar </strong>to display the items and highlights the selected one based on the <strong>currentRoute</strong>.</li>\n<li>Created the <strong>NavigationSideBar </strong>composable for large screens. It uses a <strong>NavigationRail </strong>and similarly highlights the selected\u00a0item.</li>\n</ul>\n<p>Both components are designed to switch between the unselected and selected icons, update the text style based on the route, and handle clicks with the <strong>onItemClick</strong> callback.</p>\n<blockquote>Step 5: Implement Home and Home Detail\u00a0Screens</blockquote>\n<p>To create the screens that will be displayed when navigating between the home and its detail, we define <strong>HomeScreen </strong>and <strong>HomeDetailScreen</strong>. These screens handle user input and navigation between each\u00a0other.</p>\n<pre>import androidx.compose.foundation.layout.*<br>import androidx.compose.material.icons.Icons<br>import androidx.compose.material.icons.automirrored.filled.ArrowBack<br>import androidx.compose.material3.*<br>import androidx.compose.runtime.*<br>import androidx.compose.ui.Alignment<br>import androidx.compose.ui.Modifier<br>import androidx.compose.ui.text.font.FontWeight<br>import androidx.compose.ui.unit.dp<br>import androidx.compose.ui.unit.sp<br>import androidx.navigation.NavController<br>import com.meet.bottom_navigation_bar_navigation_rail.navigation.Routes<br><br>@OptIn(ExperimentalMaterial3Api::class)<br>@Composable<br>fun HomeScreen(<br>    rootNavController: NavController, paddingValues: PaddingValues<br>) {<br>    var name by remember { mutableStateOf(\"\") }<br><br>    Column(<br>        modifier = Modifier<br>            .fillMaxSize()<br>            .padding(paddingValues),<br>        verticalArrangement = Arrangement.SpaceBetween,<br>        horizontalAlignment = Alignment.CenterHorizontally<br>    ) {<br>        TopAppBar(<br>            title = {<br>                Text(<br>                    text = \"Home\",<br>                    style = MaterialTheme.typography.headlineLarge,<br>                    fontWeight = FontWeight.Bold,<br>                    color = MaterialTheme.colorScheme.onBackground<br>                )<br>            }<br>        )<br><br>        Spacer(modifier = Modifier.height(20.dp))<br><br>        TextField(<br>            value = name,<br>            onValueChange = { name = it },<br>            label = { Text(text = \"Enter the name\") }<br>        )<br><br>        Button(onClick = {<br>            rootNavController.currentBackStackEntry?.savedStateHandle?.apply {<br>                set(\"name\", name)<br>            }<br>            rootNavController.navigate(Routes.HomeDetail.route)<br>        }) {<br>            Text(<br>                text = \"Move to Home Detail Screen\",<br>                fontSize = 20.sp<br>            )<br>        }<br><br>        Spacer(modifier = Modifier.height(20.dp))<br>    }<br>}<br><br>@OptIn(ExperimentalMaterial3Api::class)<br>@Composable<br>fun HomeDetailScreen(<br>    rootNavController: NavController,<br>    name: String<br>) {<br>    Column(<br>        modifier = Modifier.fillMaxSize(),<br>        verticalArrangement = Arrangement.SpaceBetween,<br>        horizontalAlignment = Alignment.CenterHorizontally<br>    ) {<br>        TopAppBar(<br>            title = {<br>                Text(<br>                    text = \"Home Detail\",<br>                    style = MaterialTheme.typography.headlineLarge,<br>                    fontWeight = FontWeight.Bold,<br>                    color = MaterialTheme.colorScheme.onBackground<br>                )<br>            },<br>            navigationIcon = {<br>                IconButton(onClick = { rootNavController.navigateUp() }) {<br>                    Icon(<br>                        imageVector = Icons.AutoMirrored.Filled.ArrowBack,<br>                        contentDescription = null,<br>                    )<br>                }<br>            }<br>        )<br><br>        Text(<br>            text = \"Name = ${'$'}name\",<br>            fontSize = 20.sp<br>        )<br><br>        Spacer(modifier = Modifier.height(20.dp))<br>    }<br>}</pre>\n<p>In this\u00a0step:</p>\n<ul>\n<li>\n<strong>HomeScreen </strong>allows users to input a name and navigate to <strong>HomeDetailScreen</strong>, passing the entered name using <strong>savedStateHandle</strong>.</li>\n<li>\n<strong>HomeDetailScreen </strong>displays the passed name and provides a back button to return to <strong>HomeScreen</strong>.</li>\n</ul>\n<blockquote>Step 6: Implement Setting and Setting Detail\u00a0Screens</blockquote>\n<p>Now, let\u2019s create the <strong>SettingScreen </strong>and <strong>SettingDetailScreen </strong>to manage settings in your app and allow navigation between these\u00a0screens.</p>\n<pre>import androidx.compose.foundation.layout.*<br>import androidx.compose.material.icons.Icons<br>import androidx.compose.material.icons.automirrored.filled.ArrowBack<br>import androidx.compose.material3.*<br>import androidx.compose.runtime.Composable<br>import androidx.compose.ui.Alignment<br>import androidx.compose.ui.Modifier<br>import androidx.compose.ui.text.font.FontWeight<br>import androidx.compose.ui.unit.dp<br>import androidx.compose.ui.unit.sp<br>import androidx.navigation.NavController<br>import com.meet.bottom_navigation_bar_navigation_rail.navigation.Routes<br><br>@OptIn(ExperimentalMaterial3Api::class)<br>@Composable<br>fun SettingScreen(<br>    rootNavController: NavController,<br>    paddingValues: PaddingValues<br>) {<br>    Column(<br>        modifier = Modifier<br>            .fillMaxSize()<br>            .padding(paddingValues),<br>        verticalArrangement = Arrangement.SpaceBetween,<br>        horizontalAlignment = Alignment.CenterHorizontally<br>    ) {<br>        TopAppBar(<br>            title = {<br>                Text(<br>                    text = \"Setting\",<br>                    style = MaterialTheme.typography.headlineLarge,<br>                    fontWeight = FontWeight.Bold,<br>                    color = MaterialTheme.colorScheme.onBackground<br>                )<br>            }<br>        )<br><br>        Spacer(modifier = Modifier.height(20.dp))<br><br>        Button(onClick = {<br>            rootNavController.navigate(Routes.SettingDetail.route)<br>        }) {<br>            Text(<br>                text = \"Move to Setting Detail Screen\",<br>                fontSize = 20.sp<br>            )<br>        }<br><br>        Spacer(modifier = Modifier.height(20.dp))<br>    }<br>}<br><br>@OptIn(ExperimentalMaterial3Api::class)<br>@Composable<br>fun SettingDetailScreen(<br>    rootNavController: NavController,<br>) {<br>    Column(<br>        modifier = Modifier.fillMaxSize(),<br>        verticalArrangement = Arrangement.SpaceBetween,<br>        horizontalAlignment = Alignment.CenterHorizontally<br>    ) {<br>        TopAppBar(<br>            title = {<br>                Text(<br>                    text = \"Setting Detail\",<br>                    style = MaterialTheme.typography.headlineLarge,<br>                    fontWeight = FontWeight.Bold,<br>                    color = MaterialTheme.colorScheme.onBackground<br>                )<br>            },<br>            navigationIcon = {<br>                IconButton(onClick = { rootNavController.navigateUp() }) {<br>                    Icon(<br>                        imageVector = Icons.AutoMirrored.Filled.ArrowBack,<br>                        contentDescription = null,<br>                    )<br>                }<br>            }<br>        )<br>    }<br>}</pre>\n<p>In this\u00a0step:</p>\n<ul>\n<li>\n<strong>SettingScreen </strong>presents a button to navigate to <strong>SettingDetailScreen</strong>.</li>\n<li>\n<strong>SettingDetailScreen </strong>provides a back button to return to the <strong>SettingScreen</strong>.</li>\n</ul>\n<blockquote>Step 7: Set Up the Navigation Graph</blockquote>\n<p>To handle screen navigation in your Compose Multiplatform app, set up the navigation graph. This will include both the main screens and detail screens. The <strong>RootNavGraph </strong>function will define the main structure for navigation, while the <strong>mainNavGraph </strong>function will handle the individual navigation routes.</p>\n<pre>import androidx.compose.foundation.layout.PaddingValues<br>import androidx.compose.runtime.Composable<br>import androidx.navigation.NavGraphBuilder<br>import androidx.navigation.NavHostController<br>import androidx.navigation.compose.NavHost<br>import androidx.navigation.compose.composable<br>import androidx.navigation.navigation<br>import com.meet.bottom_navigation_bar_navigation_rail.navigation.Graph<br>import com.meet.bottom_navigation_bar_navigation_rail.navigation.Routes<br>import com.meet.bottom_navigation_bar_navigation_rail.screens.HomeDetailScreen<br>import com.meet.bottom_navigation_bar_navigation_rail.screens.HomeScreen<br>import com.meet.bottom_navigation_bar_navigation_rail.screens.SettingDetailScreen<br>import com.meet.bottom_navigation_bar_navigation_rail.screens.SettingScreen<br><br>@Composable<br>fun RootNavGraph(<br>    rootNavController: NavHostController,<br>    innerPadding: PaddingValues<br>) {<br>    NavHost(<br>        navController = rootNavController,<br>        startDestination = Graph.NAVIGATION_BAR_SCREEN_GRAPH,<br>    ) {<br>        mainNavGraph(rootNavController = rootNavController, innerPadding = innerPadding)<br>        composable(<br>            route = Routes.HomeDetail.route,<br>        ) {<br>            rootNavController.previousBackStackEntry?.savedStateHandle?.get&lt;String&gt;(\"name\")?.let { name -&gt;<br>                HomeDetailScreen(rootNavController = rootNavController, name = name)<br>            }<br>        }<br>        composable(<br>            route = Routes.SettingDetail.route,<br>        ) {<br>            SettingDetailScreen(rootNavController = rootNavController)<br>        }<br>    }<br>}<br>fun NavGraphBuilder.mainNavGraph(<br>    rootNavController: NavHostController,<br>    innerPadding: PaddingValues<br>) {<br>    navigation(<br>        startDestination = Routes.Home.route,<br>        route = Graph.NAVIGATION_BAR_SCREEN_GRAPH<br>    ) {<br>        composable(route = Routes.Home.route) {<br>            HomeScreen(rootNavController = rootNavController, paddingValues = innerPadding)<br>        }<br>        composable(route = Routes.Setting.route) {<br>            SettingScreen(rootNavController = rootNavController, paddingValues = innerPadding)<br>        }<br>    }<br>}</pre>\n<p>In this\u00a0step:</p>\n<ul>\n<li>We define a <strong>RootNavGraph </strong>that starts the navigation graph and handles both main and detail\u00a0screens.</li>\n<li>\n<strong>mainNavGraph </strong>manages the navigation for the <strong>HomeScreen </strong>and <strong>SettingScreen</strong>.</li>\n<li>We use <strong>composable </strong>to declare each screen's route, and for the detail screens (<strong>HomeDetailScreen</strong>, <strong>SettingDetailScreen)</strong>, we retrieve parameters using <strong>savedStateHandle</strong> when navigating between\u00a0them.</li>\n</ul>\n<blockquote>Step 8: Building the Adaptive UI for Different Screen\u00a0Sizes</blockquote>\n<p>In this step, we\u2019ll implement the <strong>MainScreen </strong>composable, which handles displaying either the <strong>Bottom Navigation Bar</strong> or the <strong>Navigation Rail</strong> based on the screen\u00a0size.</p>\n<pre>import androidx.compose.animation.*<br>import androidx.compose.foundation.background<br>import androidx.compose.foundation.layout.Row<br>import androidx.compose.material3.MaterialTheme<br>import androidx.compose.material3.Scaffold<br>import androidx.compose.material3.windowsizeclass.ExperimentalMaterial3WindowSizeClassApi<br>import androidx.compose.material3.windowsizeclass.WindowWidthSizeClass<br>import androidx.compose.material3.windowsizeclass.calculateWindowSizeClass<br>import androidx.compose.runtime.*<br>import androidx.navigation.NavHostController<br>import androidx.navigation.compose.currentBackStackEntryAsState<br>import androidx.navigation.compose.rememberNavController<br>import com.meet.bottom_navigation_bar_navigation_rail.navigation.*<br><br>@OptIn(ExperimentalMaterial3WindowSizeClassApi::class)<br>@Composable<br>fun MainScreen() {<br>    val windowSizeClass = calculateWindowSizeClass()<br>    val isMediumExpandedWWSC by remember(windowSizeClass) {<br>        derivedStateOf {<br>            windowSizeClass.widthSizeClass != WindowWidthSizeClass.Compact<br>        }<br>    }<br>    val rootNavController = rememberNavController()<br>    val navBackStackEntry by rootNavController.currentBackStackEntryAsState()<br>    val currentRoute by remember(navBackStackEntry) {<br>        derivedStateOf {<br>            navBackStackEntry?.destination?.route<br>        }<br>    }<br>    val navigationItem by remember {<br>        derivedStateOf {<br>            navigationItemsLists.find { it.route == currentRoute }<br>        }<br>    }<br>    val isMainScreenVisible by remember(isMediumExpandedWWSC) {<br>        derivedStateOf {<br>            navigationItem != null<br>        }<br>    }<br>    val isBottomBarVisible by remember(isMediumExpandedWWSC) {<br>        derivedStateOf {<br>            if (!isMediumExpandedWWSC) {<br>                navigationItem != null<br>            } else {<br>                false<br>            }<br>        }<br>    }<br>    MainScaffold(<br>        rootNavController = rootNavController,<br>        currentRoute = currentRoute,<br>        isMediumExpandedWWSC = isMediumExpandedWWSC,<br>        isBottomBarVisible = isBottomBarVisible,<br>        isMainScreenVisible = isMainScreenVisible,<br>        onItemClick = { currentNavigationItem -&gt;<br>            rootNavController.navigate(currentNavigationItem.route) {<br>                popUpTo(rootNavController.graph.startDestinationRoute ?: \"\") {<br>                    saveState = true<br>                }<br>                launchSingleTop = true<br>                restoreState = true<br>            }<br>        }<br>    )<br>}<br><br>@Composable<br>fun MainScaffold(<br>    rootNavController: NavHostController,<br>    currentRoute: String?,<br>    isMediumExpandedWWSC: Boolean,<br>    isBottomBarVisible: Boolean,<br>    isMainScreenVisible: Boolean,<br>    onItemClick: (NavigationItem) -&gt; Unit,<br>) {<br>    Row {<br>        AnimatedVisibility(<br>            modifier = Modifier.background(MaterialTheme.colorScheme.surface),<br>            visible = isMediumExpandedWWSC &amp;&amp; isMainScreenVisible,<br>            enter = slideInHorizontally(<br>                // Slide in from the left<br>                initialOffsetX = { fullWidth -&gt; -fullWidth }<br>            ),<br>            exit = slideOutHorizontally(<br>                // Slide out to the right<br>                targetOffsetX = { fullWidth -&gt; -fullWidth }<br>            )<br>        ) {<br>            NavigationSideBar(<br>                items = navigationItemsLists,<br>                currentRoute = currentRoute,<br>                onItemClick = { currentNavigationItem -&gt;<br>                    onItemClick(currentNavigationItem)<br>                }<br>            )<br>        }<br>        Scaffold(<br>            bottomBar = {<br>                AnimatedVisibility(<br>                    visible = isBottomBarVisible,<br>                    enter = slideInVertically(<br>                        // Slide in from the bottom<br>                        initialOffsetY = { fullHeight -&gt; fullHeight }<br>                    ),<br>                    exit = slideOutVertically(<br>                        // Slide out to the bottom<br>                        targetOffsetY = { fullHeight -&gt; fullHeight }<br>                    )<br>                ) {<br>                    BottomNavigationBar(<br>                        items = navigationItemsLists,<br>                        currentRoute = currentRoute,<br>                        onItemClick = { currentNavigationItem -&gt;<br>                            onItemClick(currentNavigationItem)<br>                        }<br>                    )<br>                }<br>            }<br>        ) { innerPadding -&gt;<br>            RootNavGraph(<br>                rootNavController = rootNavController,<br>                innerPadding = innerPadding,<br>            )<br>        }<br>    }<br>}</pre>\n<p>Here, we use <strong>WindowSizeClass </strong>to dynamically adapt the UI based on the width of the device screen. If the width is compact, we show the <strong>Bottom Navigation Bar</strong>; if it\u2019s larger (like on tablets or desktops), we switch to a <strong>Navigation Rail</strong> for better usability.</p>\n<p>Here\u2019s a breakdown of how it\u00a0works:</p>\n<ul>\n<li>\n<strong>WindowSizeClass</strong>: Helps detect the screen size. We use it to differentiate between compact and expanded\u00a0layouts.</li>\n<li>\n<strong>AnimatedVisibility</strong>: This Jetpack Compose API is used to animate the transition between the Bottom Navigation Bar and the Navigation Rail. For example, when switching to a larger screen size, the Navigation Rail slides in from the left, giving a polished, responsive look.</li>\n<li>\n<strong>Scaffold</strong>: Acts as the container for the UI layout, managing the positioning of the Bottom Navigation Bar and the Navigation Rail, along with handling content\u00a0padding.</li>\n</ul>\n<p>By doing this, you create a flexible UI that works for both smaller devices like phones, where space is limited, and larger screens like tablets and desktops, where more space allows for a side navigation rail.</p>\n<blockquote>Step 9: Create the Main Composable Function</blockquote>\n<p>In this step, we\u2019ll define the <strong>App </strong>composable in the common module. This function will act as the entry point of the application, applying a <strong>MaterialTheme </strong>to the <strong>MainScreen</strong>.</p>\n<pre>import androidx.compose.material.MaterialTheme<br>import androidx.compose.runtime.Composable<br>import org.jetbrains.compose.ui.tooling.preview.Preview<br><br>@Composable<br>@Preview<br>fun App() {<br>    MaterialTheme {<br>        MainScreen()<br>    }<br>}</pre>\n<p>In this\u00a0step:</p>\n<ul>\n<li>We define the <strong>App </strong>composable, which wraps <strong>MainScreen </strong>in a <strong>MaterialTheme</strong>, ensuring a consistent look and feel across the\u00a0app.</li>\n<li>A <strong>@Preview </strong>annotation is used for quickly visualizing the <strong>App </strong>composable during development.</li>\n</ul>\n<blockquote>Step 10: Set Up the Desktop\u00a0Module</blockquote>\n<p>Now let\u2019s set up the <strong>main </strong>function in the desktop module to launch the app. This function defines the application window and the entry point of the desktop\u00a0app.</p>\n<pre>import androidx.compose.ui.window.Window<br>import androidx.compose.ui.window.application<br>import java.awt.Dimension<br><br>fun main() = application {<br>    Window(<br>        onCloseRequest = ::exitApplication,<br>        title = \"Bottom-Navigation-Bar-Navigation-Rail\",<br>    ) {<br>        window.minimumSize = Dimension(640, 480)<br>        App()<br>    }<br>}</pre>\n<p>In this\u00a0step:</p>\n<ul>\n<li>We use <strong>Window </strong>from <strong>androidx.compose.ui.window</strong> to create the desktop app's main\u00a0window.</li>\n<li>\n<strong>App()</strong> is called to display the UI within the\u00a0window.</li>\n<li>The minimum window size is set to <strong>640x480</strong> to ensure proper display on smaller\u00a0screens.</li>\n</ul>\n<h3>Conclusion</h3>\n<p>You\u2019ve successfully integrated <strong>Bottom Navigation Bar</strong> for compact screens and a <strong>Navigation Rail</strong> for larger screens in a <strong>Compose Multiplatform</strong>. Now, you can run the app on each platform\u200a\u2014\u200a<strong>Android, iOS, macOS, Linux, and Windows</strong>\u200a\u2014\u200ato ensure everything works smoothly.</p>\n<p>Example Github\u00a0Repo:</p>\n<ul>\n<li><a href=\"https://github.com/Coding-Meet/Bottom-Navigation-Bar-Navigation-Rail-KMP\">GitHub - Coding-Meet/Bottom-Navigation-Bar-Navigation-Rail-KMP</a></li>\n<li><a href=\"https://github.com/Coding-Meet/News-KMP-App\">GitHub - Coding-Meet/News-KMP-App: News Kotlin Multiplatform project designed to target Android, iOS, Windows, macOS, Linux platforms.</a></li>\n</ul>\n<a href=\"https://medium.com/media/0978046c7e7b122964874b23b4aa1223/href\">https://medium.com/media/0978046c7e7b122964874b23b4aa1223/href</a><p>If you\u2019re interested in learning more about <strong>Kotlin Multiplatform</strong> and <strong>Compose Multiplatform</strong>, check out my playlist on YouTube Channel:<br><a href=\"https://youtube.com/playlist?list=PLlSuJy9SfzvEiYH59pDDNvFJjHoYLV0MM&amp;si=DhvNC5qiYh8rXzet\"><strong>Mastering Kotlin Multiplatform with Jetpack Compose: Complete Guide in\u00a0Hindi</strong></a></p>\n<p>Thank you for reading! \ud83d\ude4c\ud83d\ude4f\u270c I hope you found this guide\u00a0useful.</p>\n<p>Don\u2019t forget to clap \ud83d\udc4f to support me and follow for more insightful articles about Android Development, Kotlin, and KMP. If you need any help related to Android, Kotlin, and KMP, I\u2019m always happy to\u00a0assist.</p>\n<h3>Explore More\u00a0Projects</h3>\n<p>If you\u2019re interested in seeing full applications built with Kotlin Multiplatform and Jetpack Compose, check out these open-source projects:</p>\n<ul>\n<li>\n<strong>News Kotlin Multiplatform App</strong> (Supports Android, iOS, Windows, macOS, Linux):<br>News KMP App is a Kotlin Compose Multiplatform (KMP) project that aims to provide a consistent news reading experience across multiple platforms, including Android, iOS, Windows, macOS, and Linux. This project leverages Kotlin\u2019s multiplatform capabilities to share code and logic while using Compose for UI, ensuring a seamless and native experience on each platform.<br>GitHub Repository: <a href=\"https://github.com/Coding-Meet/News-KMP-App\">News-KMP-App</a>\n</li>\n<li>\n<strong>Gemini AI Kotlin Multiplatform App</strong> (Supports Android, iOS, Windows, macOS, Linux, and Web):<br>Gemini AI KMP App is a Kotlin Compose Multiplatform project designed by Gemini AI where you can retrieve information from text and images in a conversational format. Additionally, it allows storing chats group-wise using SQLDelight and KStore, and facilitates changing the Gemini API key.<br>GitHub Repository: <a href=\"https://github.com/Coding-Meet/Gemini-AI-KMP-App\">Gemini-AI-KMP-App</a>\n</li>\n</ul>\n<h3>Follow me\u00a0on</h3>\n<p><a href=\"https://medium.com/@meet26\">Medium</a>\u00a0, <a href=\"https://youtube.com/@codingmeet26?si=0unoWz53pxanSpv0\">YouTube\u00a0</a>, <a href=\"https://github.com/Coding-Meet?source=about_page-------------------------------------\">GitHub</a>\u00a0, <a href=\"https://www.instagram.com/codingmeet26/?source=about_page-------------------------------------\">Instagram</a>\u00a0, <a href=\"https://www.linkedin.com/in/coding-meet?source=about_page-------------------------------------\">LinkedIn</a>\u00a0, <a href=\"https://www.buymeacoffee.com/CodingMeet?source=about_page-------------------------------------\">Buy Me a Coffee</a>\u00a0,\u00a0<a href=\"https://twitter.com/CodingMeet?source=about_page-------------------------------------\">Twitter</a></p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=c7dc3baab0e7\" width=\"1\" height=\"1\" alt=\"\"><hr>\n<p><a href=\"https://proandroiddev.com/how-to-integrate-bottom-navigation-bar-for-compact-screens-and-a-navigation-rail-for-larger-screens-c7dc3baab0e7\">How to Integrate Bottom Navigation Bar for compact screens and a Navigation Rail for larger screens\u2026</a> was originally published in <a href=\"https://proandroiddev.com/\">ProAndroidDev</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>\n","enclosure":{},"categories":["navigation","compose-multiplatform","bottomnavigationbar","kotlin-multiplatform","kotlin"]},{"title":"How to Integrate ViewModel in Kotlin Multiplatform with Koin","pubDate":"2024-09-11 08:25:22","link":"https://proandroiddev.com/how-to-integrate-viewmodel-in-kotlin-multiplatform-with-koin-1a1134530215?source=rss-b69c0e11154c------2","guid":"https://medium.com/p/1a1134530215","author":"Meet","thumbnail":"","description":"\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*cZ7ByLSeo7R4iJBUkADNbA.png\"></figure><p>In this article, we will walk through the steps required to integrate ViewModel with Koin in a Kotlin Multiplatform project. Koin is a popular dependency injection library that helps in managing object lifecycles, and Jetpack Compose provides a powerful, declarative way to build UIs in Android and across other platforms. By combining these two technologies, we can effectively manage state in a cross-platform application (Android, iOS and desktop platforms).</p>\n<blockquote>Step 1: Add Dependencies to <strong>libs.versions.toml</strong>\n</blockquote>\n<p>First, add the necessary dependencies for Koin and Lifecycle ViewModel in your <strong>libs.versions.toml</strong> file. This file defines the versions and library modules you'll use in your\u00a0project:</p>\n<pre>[versions]<br># Define the versions of the dependencies<br>koin = \"4.0.0\"<br>lifecycleViewmodel = \"2.8.2\"<br><br>[libraries]<br># Koin dependencies<br>koin-android = { module = \"io.insert-koin:koin-android\", version.ref = \"koin\" }<br>koin-androidx-compose = { module = \"io.insert-koin:koin-androidx-compose\", version.ref = \"koin\" }<br>koin-core = { module = \"io.insert-koin:koin-core\", version.ref = \"koin\" }<br>koin-compose = { module = \"io.insert-koin:koin-compose\", version.ref = \"koin\" }<br>koin-composeVM = { module = \"io.insert-koin:koin-compose-viewmodel\", version.ref = \"koin\" }<br><br># Lifecycle ViewModel<br>androidx-lifecycle-viewmodel = { module = \"org.jetbrains.androidx.lifecycle:lifecycle-viewmodel\", version.ref = \"lifecycleViewmodel\" }</pre>\n<p>Next, include these dependencies in the <strong>build.gradle.kts</strong> file of your Compose Multiplatform project to make them available across platforms:</p>\n<pre>// build.gradle.kts (Module :composeApp)<br>kotlin {<br>    sourceSets {<br>        val commonMain by getting {<br>            dependencies {<br>                // Koin<br>                api(libs.koin.core)<br>                implementation(libs.koin.compose)<br>                implementation(libs.koin.composeVM)<br><br>                // ViewModel support in common code<br>                implementation(libs.androidx.lifecycle.viewmodel)<br>            }<br>        }<br><br>        val androidMain by getting {<br>            dependencies {<br>                // Koin support for Android<br>                implementation(libs.koin.android)<br>                implementation(libs.koin.androidx.compose)<br>            }<br>        }<br><br>        // Additional source sets for iOS, Desktop as needed<br>    }<br>}</pre>\n<blockquote>Step 2: Create the ViewModel with StateFlow</blockquote>\n<p>After syncing your Gradle files, create a <strong>CounterViewModel.kt</strong> file that uses <strong>StateFlow </strong>to manage a counter variable. This will provide a shared counter logic for all platforms:</p>\n<pre>// composeApp/src/commonMain/kotlin/CounterViewModel.kt<br>import kotlinx.coroutines.flow.MutableStateFlow<br>import kotlinx.coroutines.flow.StateFlow<br>import androidx.lifecycle.ViewModel<br><br>class CounterViewModel : ViewModel() {<br>    // Define the counter variable using StateFlow<br>    private val _counter = MutableStateFlow(0)<br>    val counter: StateFlow&lt;Int&gt; = _counter<br><br>    // Increment method<br>    fun increment() {<br>        _counter.value += 1<br>    }<br><br>    // Decrement method<br>    fun decrement() {<br>        _counter.value -= 1<br>    }<br>}</pre>\n<blockquote>Step 3: Define and Implement ViewModel Modules</blockquote>\n<p>In <strong>commonMain</strong>, define the ViewModelModule using <strong>viewModelOf </strong>for a cleaner and more concise way to declare the ViewModel:</p>\n<pre>// composeApp/src/commonMain/kotlin/ViewModelModule.kt<br>import org.koin.core.module.dsl.viewModel<br>import org.koin.core.module.dsl.viewModelOf<br>import org.koin.dsl.module<br><br>val viewModelModule = module {<br>    // Old way<br>    viewModel { CounterViewModel() }<br><br>    // New way using viewModelOf<br>    viewModelOf(::CounterViewModel)<br>}</pre>\n<blockquote>\n<strong>Note</strong>: Currently, nested <strong>NavGraph </strong>or navigation with multi-stack configurations are not fully supported. The issue arises with ViewModel recreation when navigating between multiple stacks. In the future, official support for multi-back-stack navigation is expected to resolve this\u00a0problem.</blockquote>\n<blockquote>Step 4: Initialize Koin in Each\u00a0Platform</blockquote>\n<h4>Common Main</h4>\n<p>For dependency injection, initialize Koin on each platform. Create a <strong>Koin.kt</strong> file in the <strong>commonMain </strong>source\u00a0set:</p>\n<pre>// composeApp/src/commonMain/kotlin/Koin.kt<br>import org.koin.core.context.startKoin<br>import org.koin.core.KoinApplication<br>import org.koin.core.module.Module<br>import org.koin.core.context.KoinContext<br><br>fun initKoin(appDeclaration: KoinAppDeclaration = {}) =<br>    startKoin {<br>        appDeclaration()<br>        modules(<br>            viewModelModule<br>        )<br>    }</pre>\n<h4>Android</h4>\n<p>In the <strong>androidMain </strong>source set, create <strong>MyApp.kt</strong>:</p>\n<pre>// composeApp/src/androidMain/kotlin/your_package_name/MyApp.kt<br>import android.app.Application<br><br>class MyApp : Application(), KoinComponent {<br>    override fun onCreate() {<br>        super.onCreate()<br>        initKoin {<br>            androidLogger()<br>            androidContext(this@MyApp)<br>        }<br>    }<br>}</pre>\n<p>After that, we need to add the name into our <strong>AndroidMainfest.xml</strong>:</p>\n<pre>&lt;!-- composeApp/src/androidMain/AndroidManifest.xml --&gt;<br>&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;<br>&lt;manifest xmlns:android=\"http://schemas.android.com/apk/res/android\"&gt;<br><br>    &lt;!-- Add this code android:name=\".MyApp\" in application--&gt;<br>    &lt;application<br>        android:name=\".MyApp\"<br>        android:allowBackup=\"true\"<br>        android:icon=\"@mipmap/ic_launcher\"<br>        android:label=\"@string/app_name\"<br>        android:roundIcon=\"@mipmap/ic_launcher_round\"<br>        android:supportsRtl=\"true\"<br>        android:theme=\"@android:style/Theme.Material.Light.NoActionBar\"&gt;<br>        &lt;activity<br>            android:name=\".MainActivity\"<br>            android:configChanges=\"orientation|screenSize|screenLayout|keyboardHidden|mnc|colorMode|density|fontScale|fontWeightAdjustment|keyboard|layoutDirection|locale|mcc|navigation|smallestScreenSize|touchscreen|uiMode\"<br>            android:exported=\"true\"&gt;<br>            &lt;intent-filter&gt;<br>                &lt;action android:name=\"android.intent.action.MAIN\" /&gt;<br><br>                &lt;category android:name=\"android.intent.category.LAUNCHER\" /&gt;<br>            &lt;/intent-filter&gt;<br>        &lt;/activity&gt;<br>    &lt;/application&gt;<br><br>&lt;/manifest&gt;</pre>\n<h4>Desktop</h4>\n<p>In the <strong>desktopMain </strong>source set, update\u00a0<strong>main.kt</strong>:</p>\n<pre>// composeApp/src/desktopMain/kotlin/main.kt<br>import androidx.compose.ui.window.application<br><br>fun main() = application {<br>    initKoin()<br>    App()<br>}</pre>\n<h4>iOS</h4>\n<p>In the <strong>iosMain </strong>source set, configure Koin in <strong>MainViewController.kt</strong>:</p>\n<pre>// composeApp/src/iosMain/kotlin/MainViewController.kt<br>import androidx.compose.ui.platform.ComposeUIViewController<br><br>fun MainViewController() = ComposeUIViewController(<br>    configure = {<br>        initKoin()<br>    }<br>) {<br>    App()<br>}</pre>\n<blockquote>Step 5: Initialize ViewModel in Compose Using\u00a0Koin</blockquote>\n<p>To connect the <strong>ViewModel </strong>with your UI, use <strong>koinViewModel</strong>to inject the <strong>ViewModel</strong>. Update <strong>App.kt</strong> in the <strong>commonMain </strong>source set to initialize the <strong>CounterViewModel </strong>and set up the UI with a text view, increment, and decrement buttons and Finally we need to wrap our composable screens within <strong>KoinContext</strong> composable.</p>\n<pre>// composeApp/src/commonMain/kotlin/App.kt<br>import androidx.compose.runtime.Composable<br>import androidx.compose.foundation.layout.*<br>import androidx.compose.material3.Button<br>import androidx.compose.material3.Text<br>import androidx.compose.runtime.collectAsState<br>import androidx.compose.ui.Alignment<br>import androidx.compose.ui.Modifier<br>import androidx.compose.ui.unit.dp<br>import org.koin.compose.KoinContext<br>import org.koin.compose.viewmodel.koinViewModel<br><br>@Composable<br>fun App() {<br>    KoinContext {<br>        val viewModel = koinViewModel&lt;CounterViewModel&gt;()<br><br>        val counterValueState by viewModel.counter.collectAsState()<br><br>        Column(<br>            modifier = Modifier.fillMaxSize(),<br>            horizontalAlignment = Alignment.CenterHorizontally,<br>            verticalArrangement = Arrangement.Center<br>        ) {<br>            Text(text = \"Counter: ${'$'}counterValueState\")<br><br>            Spacer(modifier = Modifier.height(16.dp))<br><br>            Row {<br>                Button(onClick = { viewModel.increment() }) {<br>                    Text(text = \"Increment\")<br>                }<br><br>                Spacer(modifier = Modifier.width(16.dp))<br><br>                Button(onClick = { viewModel.decrement() }) {<br>                    Text(text = \"Decrement\")<br>                }<br>            }<br>        }<br>    }<br>}</pre>\n<h3>Conclusion</h3>\n<p>You\u2019ve successfully integrated ViewModel in Compose Multiplatform with Koin. Now, you can run the app on each platform\u200a\u2014\u200aAndroid, iOS, macOS, Linux, and Windows\u200a\u2014\u200ato ensure everything works smoothly.</p>\n<p>If you\u2019re interested in learning more about <strong>Kotlin Multiplatform</strong> and <strong>Compose Multiplatform</strong>, check out my playlist on YouTube Channel:<br><a href=\"https://youtube.com/playlist?list=PLlSuJy9SfzvEiYH59pDDNvFJjHoYLV0MM&amp;si=VR1irW3wUJchQ7iz\">Kotlin Multiplatform &amp; Compose Multiplatform</a></p>\n<p>Thank you for reading! \ud83d\ude4c\ud83d\ude4f\u270c I hope you found this guide\u00a0useful.</p>\n<p>Don\u2019t forget to clap \ud83d\udc4f to support me and follow for more insightful articles about Android Development, Kotlin, and KMP. If you need any help related to Android, Kotlin, and KMP, I\u2019m always happy to\u00a0assist.</p>\n<h3>Explore More\u00a0Projects</h3>\n<p>If you\u2019re interested in seeing full applications built with Kotlin Multiplatform and Jetpack Compose, check out these open-source projects:</p>\n<ul>\n<li>\n<strong>News Kotlin Multiplatform App</strong> (Supports Android, iOS, Windows, macOS, Linux):<br>News KMP App is a Kotlin Compose Multiplatform (KMP) project that aims to provide a consistent news reading experience across multiple platforms, including Android, iOS, Windows, macOS, and Linux. This project leverages Kotlin\u2019s multiplatform capabilities to share code and logic while using Compose for UI, ensuring a seamless and native experience on each platform.<br>GitHub Repository: <a href=\"https://github.com/Coding-Meet/News-KMP-App\">News-KMP-App</a>\n</li>\n<li>\n<strong>Gemini AI Kotlin Multiplatform App</strong> (Supports Android, iOS, Windows, macOS, Linux, and Web):<br>Gemini AI KMP App is a Kotlin Compose Multiplatform project designed by Gemini AI where you can retrieve information from text and images in a conversational format. Additionally, it allows storing chats group-wise using SQLDelight and KStore, and facilitates changing the Gemini API key.<br>GitHub Repository: <a href=\"https://github.com/Coding-Meet/Gemini-AI-KMP-App\">Gemini-AI-KMP-App</a>\n</li>\n</ul>\n<h3>Follow me\u00a0on</h3>\n<p><a href=\"https://medium.com/@meet26\">Medium</a>\u00a0, <a href=\"https://youtube.com/@codingmeet26?si=0unoWz53pxanSpv0\">YouTube\u00a0</a>, <a href=\"https://github.com/Coding-Meet?source=about_page-------------------------------------\">GitHub</a>\u00a0, <a href=\"https://www.instagram.com/codingmeet26/?source=about_page-------------------------------------\">Instagram</a>\u00a0, <a href=\"https://www.linkedin.com/in/coding-meet?source=about_page-------------------------------------\">LinkedIn</a>\u00a0, <a href=\"https://www.buymeacoffee.com/CodingMeet?source=about_page-------------------------------------\">Buy Me a Coffee</a>\u00a0,\u00a0<a href=\"https://twitter.com/CodingMeet?source=about_page-------------------------------------\">Twitter</a></p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=1a1134530215\" width=\"1\" height=\"1\" alt=\"\"><hr>\n<p><a href=\"https://proandroiddev.com/how-to-integrate-viewmodel-in-kotlin-multiplatform-with-koin-1a1134530215\">How to Integrate ViewModel in Kotlin Multiplatform with Koin</a> was originally published in <a href=\"https://proandroiddev.com/\">ProAndroidDev</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>\n","content":"\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*cZ7ByLSeo7R4iJBUkADNbA.png\"></figure><p>In this article, we will walk through the steps required to integrate ViewModel with Koin in a Kotlin Multiplatform project. Koin is a popular dependency injection library that helps in managing object lifecycles, and Jetpack Compose provides a powerful, declarative way to build UIs in Android and across other platforms. By combining these two technologies, we can effectively manage state in a cross-platform application (Android, iOS and desktop platforms).</p>\n<blockquote>Step 1: Add Dependencies to <strong>libs.versions.toml</strong>\n</blockquote>\n<p>First, add the necessary dependencies for Koin and Lifecycle ViewModel in your <strong>libs.versions.toml</strong> file. This file defines the versions and library modules you'll use in your\u00a0project:</p>\n<pre>[versions]<br># Define the versions of the dependencies<br>koin = \"4.0.0\"<br>lifecycleViewmodel = \"2.8.2\"<br><br>[libraries]<br># Koin dependencies<br>koin-android = { module = \"io.insert-koin:koin-android\", version.ref = \"koin\" }<br>koin-androidx-compose = { module = \"io.insert-koin:koin-androidx-compose\", version.ref = \"koin\" }<br>koin-core = { module = \"io.insert-koin:koin-core\", version.ref = \"koin\" }<br>koin-compose = { module = \"io.insert-koin:koin-compose\", version.ref = \"koin\" }<br>koin-composeVM = { module = \"io.insert-koin:koin-compose-viewmodel\", version.ref = \"koin\" }<br><br># Lifecycle ViewModel<br>androidx-lifecycle-viewmodel = { module = \"org.jetbrains.androidx.lifecycle:lifecycle-viewmodel\", version.ref = \"lifecycleViewmodel\" }</pre>\n<p>Next, include these dependencies in the <strong>build.gradle.kts</strong> file of your Compose Multiplatform project to make them available across platforms:</p>\n<pre>// build.gradle.kts (Module :composeApp)<br>kotlin {<br>    sourceSets {<br>        val commonMain by getting {<br>            dependencies {<br>                // Koin<br>                api(libs.koin.core)<br>                implementation(libs.koin.compose)<br>                implementation(libs.koin.composeVM)<br><br>                // ViewModel support in common code<br>                implementation(libs.androidx.lifecycle.viewmodel)<br>            }<br>        }<br><br>        val androidMain by getting {<br>            dependencies {<br>                // Koin support for Android<br>                implementation(libs.koin.android)<br>                implementation(libs.koin.androidx.compose)<br>            }<br>        }<br><br>        // Additional source sets for iOS, Desktop as needed<br>    }<br>}</pre>\n<blockquote>Step 2: Create the ViewModel with StateFlow</blockquote>\n<p>After syncing your Gradle files, create a <strong>CounterViewModel.kt</strong> file that uses <strong>StateFlow </strong>to manage a counter variable. This will provide a shared counter logic for all platforms:</p>\n<pre>// composeApp/src/commonMain/kotlin/CounterViewModel.kt<br>import kotlinx.coroutines.flow.MutableStateFlow<br>import kotlinx.coroutines.flow.StateFlow<br>import androidx.lifecycle.ViewModel<br><br>class CounterViewModel : ViewModel() {<br>    // Define the counter variable using StateFlow<br>    private val _counter = MutableStateFlow(0)<br>    val counter: StateFlow&lt;Int&gt; = _counter<br><br>    // Increment method<br>    fun increment() {<br>        _counter.value += 1<br>    }<br><br>    // Decrement method<br>    fun decrement() {<br>        _counter.value -= 1<br>    }<br>}</pre>\n<blockquote>Step 3: Define and Implement ViewModel Modules</blockquote>\n<p>In <strong>commonMain</strong>, define the ViewModelModule using <strong>viewModelOf </strong>for a cleaner and more concise way to declare the ViewModel:</p>\n<pre>// composeApp/src/commonMain/kotlin/ViewModelModule.kt<br>import org.koin.core.module.dsl.viewModel<br>import org.koin.core.module.dsl.viewModelOf<br>import org.koin.dsl.module<br><br>val viewModelModule = module {<br>    // Old way<br>    viewModel { CounterViewModel() }<br><br>    // New way using viewModelOf<br>    viewModelOf(::CounterViewModel)<br>}</pre>\n<blockquote>\n<strong>Note</strong>: Currently, nested <strong>NavGraph </strong>or navigation with multi-stack configurations are not fully supported. The issue arises with ViewModel recreation when navigating between multiple stacks. In the future, official support for multi-back-stack navigation is expected to resolve this\u00a0problem.</blockquote>\n<blockquote>Step 4: Initialize Koin in Each\u00a0Platform</blockquote>\n<h4>Common Main</h4>\n<p>For dependency injection, initialize Koin on each platform. Create a <strong>Koin.kt</strong> file in the <strong>commonMain </strong>source\u00a0set:</p>\n<pre>// composeApp/src/commonMain/kotlin/Koin.kt<br>import org.koin.core.context.startKoin<br>import org.koin.core.KoinApplication<br>import org.koin.core.module.Module<br>import org.koin.core.context.KoinContext<br><br>fun initKoin(appDeclaration: KoinAppDeclaration = {}) =<br>    startKoin {<br>        appDeclaration()<br>        modules(<br>            viewModelModule<br>        )<br>    }</pre>\n<h4>Android</h4>\n<p>In the <strong>androidMain </strong>source set, create <strong>MyApp.kt</strong>:</p>\n<pre>// composeApp/src/androidMain/kotlin/your_package_name/MyApp.kt<br>import android.app.Application<br><br>class MyApp : Application(), KoinComponent {<br>    override fun onCreate() {<br>        super.onCreate()<br>        initKoin {<br>            androidLogger()<br>            androidContext(this@MyApp)<br>        }<br>    }<br>}</pre>\n<p>After that, we need to add the name into our <strong>AndroidMainfest.xml</strong>:</p>\n<pre>&lt;!-- composeApp/src/androidMain/AndroidManifest.xml --&gt;<br>&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;<br>&lt;manifest xmlns:android=\"http://schemas.android.com/apk/res/android\"&gt;<br><br>    &lt;!-- Add this code android:name=\".MyApp\" in application--&gt;<br>    &lt;application<br>        android:name=\".MyApp\"<br>        android:allowBackup=\"true\"<br>        android:icon=\"@mipmap/ic_launcher\"<br>        android:label=\"@string/app_name\"<br>        android:roundIcon=\"@mipmap/ic_launcher_round\"<br>        android:supportsRtl=\"true\"<br>        android:theme=\"@android:style/Theme.Material.Light.NoActionBar\"&gt;<br>        &lt;activity<br>            android:name=\".MainActivity\"<br>            android:configChanges=\"orientation|screenSize|screenLayout|keyboardHidden|mnc|colorMode|density|fontScale|fontWeightAdjustment|keyboard|layoutDirection|locale|mcc|navigation|smallestScreenSize|touchscreen|uiMode\"<br>            android:exported=\"true\"&gt;<br>            &lt;intent-filter&gt;<br>                &lt;action android:name=\"android.intent.action.MAIN\" /&gt;<br><br>                &lt;category android:name=\"android.intent.category.LAUNCHER\" /&gt;<br>            &lt;/intent-filter&gt;<br>        &lt;/activity&gt;<br>    &lt;/application&gt;<br><br>&lt;/manifest&gt;</pre>\n<h4>Desktop</h4>\n<p>In the <strong>desktopMain </strong>source set, update\u00a0<strong>main.kt</strong>:</p>\n<pre>// composeApp/src/desktopMain/kotlin/main.kt<br>import androidx.compose.ui.window.application<br><br>fun main() = application {<br>    initKoin()<br>    App()<br>}</pre>\n<h4>iOS</h4>\n<p>In the <strong>iosMain </strong>source set, configure Koin in <strong>MainViewController.kt</strong>:</p>\n<pre>// composeApp/src/iosMain/kotlin/MainViewController.kt<br>import androidx.compose.ui.platform.ComposeUIViewController<br><br>fun MainViewController() = ComposeUIViewController(<br>    configure = {<br>        initKoin()<br>    }<br>) {<br>    App()<br>}</pre>\n<blockquote>Step 5: Initialize ViewModel in Compose Using\u00a0Koin</blockquote>\n<p>To connect the <strong>ViewModel </strong>with your UI, use <strong>koinViewModel</strong>to inject the <strong>ViewModel</strong>. Update <strong>App.kt</strong> in the <strong>commonMain </strong>source set to initialize the <strong>CounterViewModel </strong>and set up the UI with a text view, increment, and decrement buttons and Finally we need to wrap our composable screens within <strong>KoinContext</strong> composable.</p>\n<pre>// composeApp/src/commonMain/kotlin/App.kt<br>import androidx.compose.runtime.Composable<br>import androidx.compose.foundation.layout.*<br>import androidx.compose.material3.Button<br>import androidx.compose.material3.Text<br>import androidx.compose.runtime.collectAsState<br>import androidx.compose.ui.Alignment<br>import androidx.compose.ui.Modifier<br>import androidx.compose.ui.unit.dp<br>import org.koin.compose.KoinContext<br>import org.koin.compose.viewmodel.koinViewModel<br><br>@Composable<br>fun App() {<br>    KoinContext {<br>        val viewModel = koinViewModel&lt;CounterViewModel&gt;()<br><br>        val counterValueState by viewModel.counter.collectAsState()<br><br>        Column(<br>            modifier = Modifier.fillMaxSize(),<br>            horizontalAlignment = Alignment.CenterHorizontally,<br>            verticalArrangement = Arrangement.Center<br>        ) {<br>            Text(text = \"Counter: ${'$'}counterValueState\")<br><br>            Spacer(modifier = Modifier.height(16.dp))<br><br>            Row {<br>                Button(onClick = { viewModel.increment() }) {<br>                    Text(text = \"Increment\")<br>                }<br><br>                Spacer(modifier = Modifier.width(16.dp))<br><br>                Button(onClick = { viewModel.decrement() }) {<br>                    Text(text = \"Decrement\")<br>                }<br>            }<br>        }<br>    }<br>}</pre>\n<h3>Conclusion</h3>\n<p>You\u2019ve successfully integrated ViewModel in Compose Multiplatform with Koin. Now, you can run the app on each platform\u200a\u2014\u200aAndroid, iOS, macOS, Linux, and Windows\u200a\u2014\u200ato ensure everything works smoothly.</p>\n<p>If you\u2019re interested in learning more about <strong>Kotlin Multiplatform</strong> and <strong>Compose Multiplatform</strong>, check out my playlist on YouTube Channel:<br><a href=\"https://youtube.com/playlist?list=PLlSuJy9SfzvEiYH59pDDNvFJjHoYLV0MM&amp;si=VR1irW3wUJchQ7iz\">Kotlin Multiplatform &amp; Compose Multiplatform</a></p>\n<p>Thank you for reading! \ud83d\ude4c\ud83d\ude4f\u270c I hope you found this guide\u00a0useful.</p>\n<p>Don\u2019t forget to clap \ud83d\udc4f to support me and follow for more insightful articles about Android Development, Kotlin, and KMP. If you need any help related to Android, Kotlin, and KMP, I\u2019m always happy to\u00a0assist.</p>\n<h3>Explore More\u00a0Projects</h3>\n<p>If you\u2019re interested in seeing full applications built with Kotlin Multiplatform and Jetpack Compose, check out these open-source projects:</p>\n<ul>\n<li>\n<strong>News Kotlin Multiplatform App</strong> (Supports Android, iOS, Windows, macOS, Linux):<br>News KMP App is a Kotlin Compose Multiplatform (KMP) project that aims to provide a consistent news reading experience across multiple platforms, including Android, iOS, Windows, macOS, and Linux. This project leverages Kotlin\u2019s multiplatform capabilities to share code and logic while using Compose for UI, ensuring a seamless and native experience on each platform.<br>GitHub Repository: <a href=\"https://github.com/Coding-Meet/News-KMP-App\">News-KMP-App</a>\n</li>\n<li>\n<strong>Gemini AI Kotlin Multiplatform App</strong> (Supports Android, iOS, Windows, macOS, Linux, and Web):<br>Gemini AI KMP App is a Kotlin Compose Multiplatform project designed by Gemini AI where you can retrieve information from text and images in a conversational format. Additionally, it allows storing chats group-wise using SQLDelight and KStore, and facilitates changing the Gemini API key.<br>GitHub Repository: <a href=\"https://github.com/Coding-Meet/Gemini-AI-KMP-App\">Gemini-AI-KMP-App</a>\n</li>\n</ul>\n<h3>Follow me\u00a0on</h3>\n<p><a href=\"https://medium.com/@meet26\">Medium</a>\u00a0, <a href=\"https://youtube.com/@codingmeet26?si=0unoWz53pxanSpv0\">YouTube\u00a0</a>, <a href=\"https://github.com/Coding-Meet?source=about_page-------------------------------------\">GitHub</a>\u00a0, <a href=\"https://www.instagram.com/codingmeet26/?source=about_page-------------------------------------\">Instagram</a>\u00a0, <a href=\"https://www.linkedin.com/in/coding-meet?source=about_page-------------------------------------\">LinkedIn</a>\u00a0, <a href=\"https://www.buymeacoffee.com/CodingMeet?source=about_page-------------------------------------\">Buy Me a Coffee</a>\u00a0,\u00a0<a href=\"https://twitter.com/CodingMeet?source=about_page-------------------------------------\">Twitter</a></p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=1a1134530215\" width=\"1\" height=\"1\" alt=\"\"><hr>\n<p><a href=\"https://proandroiddev.com/how-to-integrate-viewmodel-in-kotlin-multiplatform-with-koin-1a1134530215\">How to Integrate ViewModel in Kotlin Multiplatform with Koin</a> was originally published in <a href=\"https://proandroiddev.com/\">ProAndroidDev</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>\n","enclosure":{},"categories":["koin","viewmodel","kotlin-multiplatform","kmp","compose-multiplatform"]}]}
                """.trimIndent()
}